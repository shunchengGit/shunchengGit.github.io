<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="行有不得反求诸己">
<meta property="og:type" content="website">
<meta property="og:title" content="宿于松下的技术博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="宿于松下的技术博客">
<meta property="og:description" content="行有不得反求诸己">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="宿于松下">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>宿于松下的技术博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">宿于松下的技术博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">19</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/11/22/2015-11-22-%E4%BB%8ENSString%E5%AF%B9%E8%B1%A1copy%E5%92%8CmutableCopy%E8%B0%88%E8%B5%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/img/common/avatar.jpg">
      <meta itemprop="name" content="宿于松下">
      <meta itemprop="description" content="行有不得反求诸己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="宿于松下的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2015/11/22/2015-11-22-%E4%BB%8ENSString%E5%AF%B9%E8%B1%A1copy%E5%92%8CmutableCopy%E8%B0%88%E8%B5%B7/" class="post-title-link" itemprop="url">从copy和mutableCopy谈起</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-11-22 00:00:00" itemprop="dateCreated datePublished" datetime="2015-11-22T00:00:00+08:00">2015-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-15 17:11:41" itemprop="dateModified" datetime="2021-08-15T17:11:41+08:00">2021-08-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-copy和mutableCopy"><a href="#1-copy和mutableCopy" class="headerlink" title="1 copy和mutableCopy"></a>1 copy和mutableCopy</h1><p>NSObject类有两个跟拷贝相关的方法——<code>copy</code>和<code>mutableCopy</code>。这两个方法都是返回一个id类型的对象，那么这两者之间有什么区别呢？根据官方文档解释，<code>copy</code>方法，返回<code>copyWithZone</code>方法返回的对象（Returns the object returned by copyWithZone:）。而<code>mutableCopy</code>方法，返回<code>mutableCopyWithZone</code>方法返回的对象(Returns the object returned by mutableCopyWithZone:)。读起来有点绕，一言以蔽之，调用<code>copy</code>就是调用<code>copyWithZone</code>，调用<code>mutableCopy</code>就是调用<code>mutableCopyWithZone</code>。<strong>还是不够清楚！！！</strong>接下来我们以NSString为例子，来说明<code>copy</code>和<code>mutableCopy</code>的区别。</p>
<h2 id="1-1-NSString对象调用copy和mutableCopy"><a href="#1-1-NSString对象调用copy和mutableCopy" class="headerlink" title="1.1 NSString对象调用copy和mutableCopy"></a>1.1 NSString对象调用copy和mutableCopy</h2><p>那么对NSString对象调用copy和mutableCopy究竟有什么效果呢？<br>在实验之前先定义如下通用宏</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印方法名</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_METHOD_NAME &#123;NSLog(@<span class="meta-string">&quot;%@&quot;</span>, NSStringFromSelector(_cmd));&#125;</span></span><br><span class="line"><span class="comment">//打印对象的类名，以及对象本身的地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_OBJ_ADDRESS(obj) &#123;NSLog(@<span class="meta-string">&quot;%@ : %p&quot;</span>,NSStringFromClass([obj class]), obj);&#125;</span></span><br><span class="line"><span class="comment">//打印空行</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_END &#123;NSLog(@<span class="meta-string">&quot;%@&quot;</span>, @<span class="meta-string">&quot; &quot;</span>);&#125;</span></span><br></pre></td></tr></table></figure>

<p>测试代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)stringCopyTest</span><br><span class="line">&#123;</span><br><span class="line">    LOG_METHOD_NAME</span><br><span class="line">    <span class="built_in">NSString</span> *str = <span class="string">@&quot;Hello&quot;</span>;</span><br><span class="line">    LOG_OBJ_ADDRESS(str);</span><br><span class="line">    <span class="built_in">NSString</span> *cpStr = [str <span class="keyword">copy</span>];</span><br><span class="line">    LOG_OBJ_ADDRESS(cpStr);</span><br><span class="line">    <span class="built_in">NSMutableString</span> *mutCpStr = [str mutableCopy];</span><br><span class="line">    LOG_OBJ_ADDRESS(mutCpStr);</span><br><span class="line">    LOG_END</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2015-11-22 19:58:05.738 CopyTest[17230:1045019] stringCopyTest</span><br><span class="line">2015-11-22 19:58:05.738 CopyTest[17230:1045019] __NSCFConstantString : 0x100fee0b0</span><br><span class="line">2015-11-22 19:58:05.738 CopyTest[17230:1045019] __NSCFConstantString : 0x100fee0b0</span><br><span class="line">2015-11-22 19:58:05.738 CopyTest[17230:1045019] __NSCFString : 0x7fabbaa00190</span><br><span class="line">2015-11-22 19:58:05.738 CopyTest[17230:1045019]  </span><br></pre></td></tr></table></figure>

<p>由以上输出可知，对一个NSString对象调用copy返回的还是该对象本身，因为str的地址和cpStr的地址是同一个。而调用mutableCopy，返回的是一个NSMutableString对象(注：__NSCFConstantString是常量串即NSString，而__NSCFString是可变串即NSMutableString）。</p>
<h2 id="1-2-NSMutableString对象调用copy和mutableCopy"><a href="#1-2-NSMutableString对象调用copy和mutableCopy" class="headerlink" title="1.2 NSMutableString对象调用copy和mutableCopy"></a>1.2 NSMutableString对象调用copy和mutableCopy</h2><p>同理，引申到NSMutableString对象呢？<br>测试代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)mutableStringCopyTest</span><br><span class="line">&#123;</span><br><span class="line">    LOG_METHOD_NAME</span><br><span class="line">    <span class="built_in">NSMutableString</span> *mutStr = [<span class="string">@&quot;OC&quot;</span> mutableCopy];</span><br><span class="line">    LOG_OBJ_ADDRESS(mutStr);</span><br><span class="line">    <span class="built_in">NSMutableString</span> *cpMutStr = [mutStr <span class="keyword">copy</span>];</span><br><span class="line">    LOG_OBJ_ADDRESS(cpMutStr);</span><br><span class="line">    <span class="built_in">NSMutableString</span> *mutCpMutStr = [mutStr mutableCopy];</span><br><span class="line">    LOG_OBJ_ADDRESS(mutCpMutStr);</span><br><span class="line">    LOG_END</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2015-11-22 19:58:05.738 CopyTest[17230:1045019] mutableStringCopyTest</span><br><span class="line">2015-11-22 19:58:05.738 CopyTest[17230:1045019] __NSCFString : 0x7fabba9012c0</span><br><span class="line">2015-11-22 19:58:05.739 CopyTest[17230:1045019] NSTaggedPointerString : 0xa0000000000434f2</span><br><span class="line">2015-11-22 19:58:05.739 CopyTest[17230:1045019] __NSCFString : 0x7fabb840a860</span><br><span class="line">2015-11-22 19:58:05.739 CopyTest[17230:1045019]  </span><br></pre></td></tr></table></figure>

<p>由以上输出可知，对一个NSMutableString对象调用copy返回的是一个NSTaggedPointerString对象，该对象可认为是一个常量串。而调用mutableCopy返回的是另外一个可变对象__NSCFString，即NSMutableString（原NSMutableString对象的地址是0x7fabba9012c0，新NSMutableString对象地址是0x7fabb840a860）。</p>
<p><strong>针对NSArray、NSDictionary、NSSet等具有Mutable版本的类进行试验出现跟NSString类似的现象，不一一列举，有兴趣可以自己去试验。</strong></p>
<h2 id="1-3-copy和mutableCopy调用小结"><a href="#1-3-copy和mutableCopy调用小结" class="headerlink" title="1.3 copy和mutableCopy调用小结"></a>1.3 copy和mutableCopy调用小结</h2><ul>
<li>针对不可变对象调用copy返回该对象本身，调用mutableCopy返回一个可变对象（新的）；</li>
<li>针对可变对象调用copy返回一个不可变对象（新的），调用mutableCopy返回另外一个可变对象（新的）。</li>
</ul>
<table>
<thead>
<tr>
<th>class</th>
<th>copy</th>
<th>mutableCopy</th>
</tr>
</thead>
<tbody><tr>
<td>不可变（如，NSString）</td>
<td>返回本身（其他什么都不干）</td>
<td>创建新的可变对象（如，创建一个NSMutableString对象，地址跟原对象不同）</td>
</tr>
<tr>
<td>可变（如，NSMutableString）</td>
<td>创建新的不可变对象（如，创建一个NSTaggedPointerString对象，地址跟原对象不同 ）</td>
<td>创建新的可变对象（如，创建一个NSMutableString对象，地址跟原对象不同  ）</td>
</tr>
</tbody></table>
<p>再进一步从是否新建返回对象，返回对象是否可变两个角度总结如下：</p>
<ul>
<li>只有不可变的copy是返回本身（其他什么都不干），其他都是创建一个新对象； </li>
<li>copy返回的是不可变对象，mutableCopy返回的是可变对象。</li>
</ul>
<h1 id="2-属性copy还是strong"><a href="#2-属性copy还是strong" class="headerlink" title="2 属性copy还是strong?"></a>2 属性copy还是strong?</h1><p>假设有两个id类型的属性如下:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="keyword">id</span> cpID;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> stID;</span><br></pre></td></tr></table></figure>

<p>那么编译器把以上两属性分别实现为:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setCpID:(<span class="keyword">id</span>)cpID &#123;</span><br><span class="line">    _cpID = [cpID <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)cpID &#123;</span><br><span class="line">    <span class="keyword">return</span> _cpID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setStID:(<span class="keyword">id</span>)stID &#123;</span><br><span class="line">    _stID = stID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)stID &#123;</span><br><span class="line">    <span class="keyword">return</span> _stID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从以上实现可以看出，strong和copy的属性主要是set方法有区别，strong的set是直接设置指定值，<strong>而copy的set是设置指定值的copy版本</strong>。接下来探索一下NSString、NSMutableString的copy和strong属性。</p>
<h2 id="2-1-NSString属性copy还是strong"><a href="#2-1-NSString属性copy还是strong" class="headerlink" title="2.1 NSString属性copy还是strong?"></a>2.1 NSString属性copy还是strong?</h2><p>测试代码如下:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *cpStr;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *stStr;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)stringPropertyTest</span><br><span class="line">&#123;</span><br><span class="line">    LOG_METHOD_NAME</span><br><span class="line">    <span class="built_in">NSMutableString</span> *mutStr = [<span class="string">@&quot;123&quot;</span> mutableCopy];</span><br><span class="line">    LOG_OBJ_ADDRESS(mutStr);</span><br><span class="line">    <span class="keyword">self</span>.cpStr = mutStr;</span><br><span class="line">    LOG_OBJ_ADDRESS(<span class="keyword">self</span>.cpStr);</span><br><span class="line">    <span class="keyword">self</span>.stStr = mutStr;</span><br><span class="line">    LOG_OBJ_ADDRESS(<span class="keyword">self</span>.stStr);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;修改前&quot;</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;mutStr：%@&quot;</span>, mutStr);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;copy：%@&quot;</span>, <span class="keyword">self</span>.cpStr);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;strong：%@&quot;</span>, <span class="keyword">self</span>.stStr);</span><br><span class="line">    </span><br><span class="line">    [mutStr appendString:<span class="string">@&quot;456&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;修改后&quot;</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;mutStr：%@&quot;</span>, mutStr);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;copy：%@&quot;</span>, <span class="keyword">self</span>.cpStr);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;strong：%@&quot;</span>, <span class="keyword">self</span>.stStr);</span><br><span class="line">    </span><br><span class="line">    LOG_END</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2015-11-22 21:11:29.458 CopyTest[17977:1317284] stringPropertyTest</span><br><span class="line">2015-11-22 21:11:29.458 CopyTest[17977:1317284] __NSCFString : 0x7fad23409b80</span><br><span class="line">2015-11-22 21:11:29.458 CopyTest[17977:1317284] NSTaggedPointerString : 0xa000000003332313</span><br><span class="line">2015-11-22 21:11:29.458 CopyTest[17977:1317284] __NSCFString : 0x7fad23409b80</span><br><span class="line">2015-11-22 21:11:29.458 CopyTest[17977:1317284] 修改前</span><br><span class="line">2015-11-22 21:11:29.458 CopyTest[17977:1317284] mutStr：123</span><br><span class="line">2015-11-22 21:11:29.458 CopyTest[17977:1317284] copy：123</span><br><span class="line">2015-11-22 21:11:29.458 CopyTest[17977:1317284] strong：123</span><br><span class="line">2015-11-22 21:11:29.458 CopyTest[17977:1317284] 修改后</span><br><span class="line">2015-11-22 21:11:29.458 CopyTest[17977:1317284] mutStr：123456</span><br><span class="line">2015-11-22 21:11:29.459 CopyTest[17977:1317284] copy：123</span><br><span class="line">2015-11-22 21:11:29.459 CopyTest[17977:1317284] strong：123456</span><br><span class="line">2015-11-22 21:11:29.459 CopyTest[17977:1317284]  </span><br></pre></td></tr></table></figure>

<p>由以上输出可知，假设两个NSString属性实际上指向的都是一个NSMutableString对象，那么在原NSMutableString对象修改后，strong版本的NSString属性跟着修改，而copy版本属性保持原状。self.cpStr实际上是一个NSTaggedPointerString对象，该对象正是NSMutableString对象执行copy的返回值。</p>
<h2 id="2-2-NSMutableString属性copy还是strong"><a href="#2-2-NSMutableString属性copy还是strong" class="headerlink" title="2.2 NSMutableString属性copy还是strong"></a>2.2 NSMutableString属性copy还是strong</h2><p>测试代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSMutableString</span> *cpMutStr;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableString</span> *stMutStr;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)mutableStringPropertyTest</span><br><span class="line">&#123;</span><br><span class="line">    LOG_METHOD_NAME</span><br><span class="line">    <span class="built_in">NSMutableString</span> *mutStr = [<span class="string">@&quot;123&quot;</span> mutableCopy];</span><br><span class="line">    LOG_OBJ_ADDRESS(mutStr);</span><br><span class="line">    <span class="keyword">self</span>.cpMutStr = mutStr;</span><br><span class="line">    LOG_OBJ_ADDRESS(<span class="keyword">self</span>.cpMutStr);</span><br><span class="line">    <span class="keyword">self</span>.stMutStr = mutStr;</span><br><span class="line">    LOG_OBJ_ADDRESS(<span class="keyword">self</span>.stMutStr);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;修改前&quot;</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;mutStr：%@&quot;</span>, mutStr);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;copy：%@&quot;</span>, <span class="keyword">self</span>.cpMutStr);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;strong：%@&quot;</span>, <span class="keyword">self</span>.stMutStr);</span><br><span class="line">    </span><br><span class="line">    [mutStr appendString:<span class="string">@&quot;456&quot;</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;修改后&quot;</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;mutStr：%@&quot;</span>, mutStr);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;copy：%@&quot;</span>, <span class="keyword">self</span>.cpMutStr);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;strong：%@&quot;</span>, <span class="keyword">self</span>.stMutStr);</span><br><span class="line">    LOG_END</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2015-11-22 21:48:21.774 CopyTest[18508:1539502] mutableStringPropertyTest</span><br><span class="line">2015-11-22 21:48:21.774 CopyTest[18508:1539502] __NSCFString : 0x7f806879b620</span><br><span class="line">2015-11-22 21:48:21.774 CopyTest[18508:1539502] NSTaggedPointerString : 0xa000000003332313</span><br><span class="line">2015-11-22 21:48:21.774 CopyTest[18508:1539502] __NSCFString : 0x7f806879b620</span><br><span class="line">2015-11-22 21:48:21.774 CopyTest[18508:1539502] 修改前</span><br><span class="line">2015-11-22 21:48:21.774 CopyTest[18508:1539502] mutStr：123</span><br><span class="line">2015-11-22 21:48:21.774 CopyTest[18508:1539502] copy：123</span><br><span class="line">2015-11-22 21:48:21.774 CopyTest[18508:1539502] strong：123</span><br><span class="line">2015-11-22 21:48:21.775 CopyTest[18508:1539502] 修改后</span><br><span class="line">2015-11-22 21:48:21.775 CopyTest[18508:1539502] mutStr：123456</span><br><span class="line">2015-11-22 21:48:21.775 CopyTest[18508:1539502] copy：123</span><br><span class="line">2015-11-22 21:48:21.775 CopyTest[18508:1539502] strong：123456</span><br><span class="line">2015-11-22 21:48:21.775 CopyTest[18508:1539502]  </span><br></pre></td></tr></table></figure>

<p>看起来没啥问题，strong版本的属性跟随原对象的变化而变化，copy版本的属性不变。但是，假设调用</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.cpMutStr appendString:<span class="string">@&quot;789&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>程序会崩溃。崩溃信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2015-11-22 21:51:37.282 CopyTest[18542:1545579] *** Terminating app due to uncaught exception &#39;NSInvalidArgumentException&#39;, reason: &#39;-[NSTaggedPointerString appendString:]: unrecognized selector sent to instance 0xa000000003332313&#39;</span><br><span class="line">*** First throw call stack:</span><br></pre></td></tr></table></figure>

<p>原因很明显，是朝NSTaggedPointerString对象发了一个它不能识别的selector。原因是copy版本的NSMutableString属性本质上不是一个NSMutableString对象，而是一个NSTaggedPointerString对象，它是一个不可变对象。该对象是NSMutableString对象执行copy得来的，还记得我们上一节的结论吗？对一个对象执行copy得到的用于是一个不可变的对象。</p>
<p><strong>针对NSArray、NSDictionary、NSSet等具有Mutable版本的类进行试验出现跟NSString类似的现象。</strong></p>
<h2 id="2-3-结论"><a href="#2-3-结论" class="headerlink" title="2.3 结论"></a>2.3 结论</h2><ul>
<li>不可变类型属性，<strong>推荐使用copy</strong>，因为假设该对象实际上指向的是一个mutable的对象，mutable对象的改变不会导致该对象的改变；假设指向的不是mutable的对象，那么copy和strong是等价，因为对一个不可变对象调用一次copy什么事情都不发生，_cpID = [cpID copy] 等价于_cpID = cpID。</li>
<li>可变类型属性，<strong>不能使用copy</strong>，因为copy产生的对象是一个不可变对象，跟属性描述是冲突的。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/13/2015-09-13-%E5%BC%80%E5%8F%91%E5%A2%A8%E8%BF%B9%E5%A4%A9%E6%B0%94App%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/img/common/avatar.jpg">
      <meta itemprop="name" content="宿于松下">
      <meta itemprop="description" content="行有不得反求诸己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="宿于松下的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2015/09/13/2015-09-13-%E5%BC%80%E5%8F%91%E5%A2%A8%E8%BF%B9%E5%A4%A9%E6%B0%94App%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E5%9F%BA%E7%A1%80%E5%BA%93%EF%BC%89/" class="post-title-link" itemprop="url">开发墨迹天气App中遇到的问题总结（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-09-13 00:00:00" itemprop="dateCreated datePublished" datetime="2015-09-13T00:00:00+08:00">2015-09-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-15 17:11:41" itemprop="dateModified" datetime="2021-08-15T17:11:41+08:00">2021-08-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">实战总结</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1数字溢出"><a href="#1数字溢出" class="headerlink" title="1数字溢出"></a>1数字溢出</h3><p><strong>背景</strong></p>
<p>写iOS代码经常需要在某处计算时间戳。通常时间戳是<a target="_blank" rel="noopener" href="http://baike.baidu.com/link?url=DOSrWUI6cHGLtuFZJS6q59Tc3-VDSYsoBT-q0sRr2k2RUEnIN8IEdfq3Dyj6A9XJ3vM8eZOz0DUeTSZDOQbFOa">格林威治时间</a>(即零时区时间)1970年1月1日0点至当前的毫秒数。例如北京时间(东八区)2015-7-4 10:35:6，的时间戳是1435977306000。就目前来说它是个13位数字。</p>
<p><strong>现象</strong></p>
<p>某种时间戳转为string的方式如下。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> st = [[<span class="built_in">NSDate</span> date] timeIntervalSince1970] * <span class="number">1000</span>;</span><br><span class="line"><span class="built_in">NSString</span> *strSt = [@(st) stringValue];</span><br></pre></td></tr></table></figure>

<p>用5s及以上的模拟器跑都能得到正确的结果。而用5s以下的模拟器跑都输出错误的值。</p>
<p><strong>解释</strong></p>
<p>产生该问题的原因如下：对于iOS的64位应用，long是8byte整数，涵盖-9223372036854775808 到 +9223372036854775807。而32位的iOS应用，long是4byte整数，涵盖-2147483648 到 +2147483647。32位下long最多只能表征10位正数，而我们的时间戳是13位的，显然数字溢出了。而对于64位的iOS应用long能表示19位正数，这是毫无压力的。详见<a target="_blank" rel="noopener" href="http://blog.csdn.net/sakulafly/article/details/41089411">iOS上应用如何兼容32位系统和64位系统</a></p>
<p><strong>解法</strong></p>
<p>我们观察到不管是IPL32规范还是IPL64规范，long long都是以8byte存储，能表征时间戳。所以此问题的正确姿势是用long long来存储时间戳。正确代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> st = [[<span class="built_in">NSDate</span> date] timeIntervalSince1970] * <span class="number">1000</span>;</span><br><span class="line"><span class="built_in">NSString</span> *strSt = [@(st) stringValue];</span><br></pre></td></tr></table></figure>

<h3 id="2NSDictionary使用不当"><a href="#2NSDictionary使用不当" class="headerlink" title="2NSDictionary使用不当"></a>2NSDictionary使用不当</h3><p><strong>背景</strong></p>
<p>iOS客户端跟服务器进行通信通常采用json格式。客户端从服务器上获取数据后，使用NSJSONSerialization把json串变为NSDictionary。早期，在不使用Mantle等第三方库做NSDictionary到Model转换的时候，我们需要自己去把Dic模型化。NSDictionary中的key是一个符合NSCopying协议的objc对象，通常我们用NSString作为Dic的key。NSDictionary中的value需要是一个objc对象。</p>
<p><strong>现象</strong></p>
<p>某次Dic模型化转换如下。其中，AppData是需要转换的模型。webType是一个BOOL量。发现该BOOL一直为YES。不受wap_type的控制。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AppData *appData = [[AppData alloc] initWithAppId:[dic[<span class="string">@&quot;app_id&quot;</span>] integerValue]</span><br><span class="line">                                            iconURL:dic[<span class="string">@&quot;app_icon&quot;</span>]</span><br><span class="line">                                            appName:dic[<span class="string">@&quot;app_name&quot;</span>]</span><br><span class="line">                                            linkUrl:urlStr</span><br><span class="line">                                            webType:(<span class="built_in">BOOL</span>)dic[<span class="string">@&quot;wap_type&quot;</span>]</span><br><span class="line">                                              appTip:dic[<span class="string">@&quot;app_desc&quot;</span>]</span><br><span class="line">                                        andAppMarks:appMarks];</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong></p>
<p><strong>(BOOL)dic[@”wap_type”]</strong></p>
<p>这种写法  ，是取出dic中@”wap_type”这个key的value，该value是一个objc对象，把该对象强制转换为BOOL类型。因此，只要dic中含有 @”wap_type”这个key对应的value的时候会是YES，否则是NO。它不会考虑这个value具体是YES还是NO。</p>
<p><strong>解法</strong></p>
<p><strong>[dic[@”wap_type”] integerValue]</strong></p>
<p>取出dic中@”wap_type”这个key的value，获取该value的integerValue。</p>
<h3 id="3NSArray-NSMutableArray相关问题"><a href="#3NSArray-NSMutableArray相关问题" class="headerlink" title="3NSArray  NSMutableArray相关问题"></a>3NSArray  NSMutableArray相关问题</h3><p><strong>背景</strong></p>
<p>NSArray和NSMutableArray是常用的objc容器，该容器常用于存储objc对象。</p>
<p><strong>现象</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSArray</span> *testAry = [[<span class="built_in">NSArray</span> alloc] init] ;</span><br><span class="line"><span class="keyword">id</span> firstObj = [testAry objectAtIndex:<span class="number">0</span>];</span><br><span class="line"><span class="keyword">id</span> lastObj = [testAry objectAtIndex:testAry.cout - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//例2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TestClass</span> : <span class="title">NSObject</span> </span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)createObj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TestClass</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)createObj &#123;</span><br><span class="line">    <span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;外部调用代码</span></span><br><span class="line">TestClass * __<span class="keyword">weak</span> weakTestObj = someStrongTestObj;</span><br><span class="line">[<span class="keyword">self</span> foo:^&#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *ary = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">    [ary addObject:[weakTestObj createObj]];</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 外部调用代码&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例1</p>
<p> 对一个空NSArray（注意空NSArray！！！不是nil NSArray，两者不是一样的东西），访问第一个和最后一个对象，都会抛出 NSRangeException。如果不抓异常，程序会崩溃。</p>
<p>例2 </p>
<p>**[ary addObject:[weakTestObj createObj]]**这函数调用有时候会抛出NSInvalidArgumentException。如果不抓异常，程序会崩溃。</p>
<p><strong>解释</strong></p>
<p>对于例1，<strong>NSArray通过index访问对象，如果index超限那么会抛出异常。这种函数的函数名一般都有一个AtIndex。</strong>这一点是要记住的！！！</p>
<p>对于例2，weakTestObj是一个weak对象，在其指向的对象被销毁后，weakTestObj可能是nil。那么，[weakTestObj createObj]函数会返回nil，在此种情况下[ary addObject:[weakTestObj createObj]]可能会抛出异常。</p>
<p><strong>解法</strong></p>
<p>这里给出一些常用的解决方案：</p>
<p>1）index访问对象通过条件语句判断index是否在合理范围内。<strong>NSArray的第一个对象访问推荐用firstObject属性，最后一个对象访问推荐用lastObject属性。</strong>；</p>
<p>2）给NSMutableArray添加对象要做nil判断；</p>
<p>3）用try catch包一下，设置异常处理逻辑。（终极杀招）</p>
<h3 id="4NSString-NSMutableString相关问题"><a href="#4NSString-NSMutableString相关问题" class="headerlink" title="4NSString NSMutableString相关问题"></a>4NSString NSMutableString相关问题</h3><p><strong>背景</strong></p>
<p>在项目中经常需要比较两个string是否相等，取某个string的sub string，对一个mutable string添加string。</p>
<p><strong>现象</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例1</span></span><br><span class="line"><span class="built_in">NSString</span> *test = [<span class="string">@&quot;123&quot;</span> mutableCopy] ;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, test == <span class="string">@&quot;123&quot;</span> ? <span class="string">@&quot;相等&quot;</span> : <span class="string">@&quot;不等&quot;</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, [test isEqualToString:<span class="string">@&quot;123&quot;</span>] ? <span class="string">@&quot;相等&quot;</span> : <span class="string">@&quot;不等&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//例2</span></span><br><span class="line"><span class="built_in">NSMutableString</span> *str = [<span class="string">@&quot;123&quot;</span> mutableCopy];</span><br><span class="line">[str appendString:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//例3</span></span><br><span class="line"><span class="built_in">NSString</span> *str = [<span class="string">@&quot;123&quot;</span> mutableCopy];</span><br><span class="line"><span class="built_in">NSString</span> *subStr = [str substringFromIndex:str.length + <span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>例1</p>
<p>输出：不等、相等</p>
<p>例2</p>
<p>抛出非法参数异常</p>
<p>例3</p>
<p>抛出范围异常</p>
<p><strong>解释</strong></p>
<p>例1，两个string比较其内容是否相同要用*<em>- (BOOL)isEqualToString:(NSString <em>)aString</em></em>方法。不要直接用”==”操作符比较。”==”操作符比较的是操作符两边的oc对象是否是同一个oc对象，这个问题可以从c语言指针的角度来思考。而*<em>- (BOOL)isEqualToString:(NSString <em>)aString</em></em>是类似于c语言的库函数**int strcmp(const char <em>str1, const char <em>str2)</em></em>。</p>
<p>例2和例3，其实跟上述NSArray  NSMutableArray相关问题类似。访问之前判断范围，添加内容判断nil。</p>
<p><strong>解法</strong></p>
<p>1）NSString判等用*<em>- (BOOL)isEqualToString:(NSString <em>)aString</em></em>；</p>
<p>2）NSString和NSMutableString操作的时候要注意异常处理，一般含有Index的这种要注意范围异常，append这种要注意传参异常；当然终极杀招依旧是try catch</p>
<h3 id="5表里不一，看起来是个NSString对象，实际上是其他对象"><a href="#5表里不一，看起来是个NSString对象，实际上是其他对象" class="headerlink" title="5表里不一，看起来是个NSString对象，实际上是其他对象"></a>5表里不一，看起来是个NSString对象，实际上是其他对象</h3><p><strong>背景</strong></p>
<p>由于项目原因，针对id号这种参数，早期服务器传参可能使用的是string。而服务器端代码重构后，是使用整数传参。</p>
<p><strong>现象</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *topicId = dic[<span class="string">@&quot;tId&quot;</span>]; <span class="comment">//dic是NSJSONSerialization解析json串得到的字典</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断topicId是否为空</span></span><br><span class="line"><span class="keyword">if</span> (![topicId length]) &#123;</span><br><span class="line"><span class="comment">//对于一个NSString对象调用length判空可以判断两种情况，一种是该对象为nil，另一种是该对象是空串@&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>调用上述代码后，程序会崩溃。</p>
<p><strong>解释</strong></p>
<p>由于服务端重构，把json中的string变成了int，所以*<em>NSString <em>topicId = dic[@”tId”]</em></em>此处实际得到的是一个NSNumber对象，对NSNumber调用length方法会出现未知选择子崩溃。</p>
<p><strong>解法</strong></p>
<p>1）树立信念，不要相信服务器会100%传好数据给你，即使正确率有99.9%那剩下的0.1%就是异常；</p>
<p>2）从服务器上得到的数据总应该进行类型判断，具体做法是用**- (BOOL)isKindOfClass:(Class)aClass<strong>或</strong>- (BOOL)isMemberOfClass:(Class)aClass**这两种方法；</p>
<p>3）用try catch包，做异常处理（终极解法）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/13/2015-09-13-%E5%BC%80%E5%8F%91%E5%A2%A8%E8%BF%B9%E5%A4%A9%E6%B0%94App%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88UIKit%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/img/common/avatar.jpg">
      <meta itemprop="name" content="宿于松下">
      <meta itemprop="description" content="行有不得反求诸己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="宿于松下的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2015/09/13/2015-09-13-%E5%BC%80%E5%8F%91%E5%A2%A8%E8%BF%B9%E5%A4%A9%E6%B0%94App%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88UIKit%EF%BC%89/" class="post-title-link" itemprop="url">开发墨迹天气App中遇到的问题总结（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-09-13 00:00:00" itemprop="dateCreated datePublished" datetime="2015-09-13T00:00:00+08:00">2015-09-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-15 17:11:41" itemprop="dateModified" datetime="2021-08-15T17:11:41+08:00">2021-08-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">实战总结</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1UIViewController生命周期函数勿忘调用相应的super函数"><a href="#1UIViewController生命周期函数勿忘调用相应的super函数" class="headerlink" title="1UIViewController生命周期函数勿忘调用相应的super函数"></a>1UIViewController生命周期函数勿忘调用相应的super函数</h3><p><strong>背景</strong></p>
<p>当我们创建一个UIViewController类的对象时，通常系统会生成几个默认的方法，这些方法大多与视图的调用有关。</p>
<p>通常上述方法包括如下几种，这些方法都是UIViewController类的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad;</span><br><span class="line">- (<span class="keyword">void</span>)viewDidUnload;</span><br><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated;</span><br><span class="line">- (<span class="keyword">void</span>)viewDidAppear:(<span class="built_in">BOOL</span>)animated;</span><br><span class="line">- (<span class="keyword">void</span>)viewWillDisappear:(<span class="built_in">BOOL</span>)animated;</span><br><span class="line">- (<span class="keyword">void</span>)viewDidDisappear:(<span class="built_in">BOOL</span>)animated;</span><br></pre></td></tr></table></figure>

<p>详见<a target="_blank" rel="noopener" href="http://blog.csdn.net/huifeidexin_1/article/details/7566226">UIViewController的生命周期及iOS程序执行顺序</a></p>
<p>iOS工程有一种常见的工程实践方法——项目中做一个base UIViewController，假设为BaseViewController。之后，所有页面控制器不要直接继承UIViewController，而是继承BaseViewController。BaseViewController针对所有的页面控制器做一些通用设置。比如：设置navigation bar的颜色，设置navigation bar的默认按钮，通用事件统计（如，某个页面控制器的展示次数），通用全局手势，通用内存警告处理等。</p>
<p><strong>现象</strong></p>
<p>某次调试发现自定义的页面控制器并未正确设置navigation bar的颜色。代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BaseViewController</span> : <span class="title">UIViewController</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BaseViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//其他代码...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置导航条外观</span></span><br><span class="line">    [<span class="keyword">self</span> setNavigationBarAppearance];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//其他代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) hellWorld &#123;</span><br><span class="line">    [<span class="keyword">super</span> helloWo];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyViewController</span> : <span class="title">BaseViewController</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    <span class="comment">//[super viewWillAppear:animated];</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//其他代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p><strong>解释</strong></p>
<p>BaseViewController在**- (void)viewWillAppear:(BOOL)animated<strong>函数做了导航条外观的通用设置。而，MyViewController并未在</strong>- (void)viewWillAppear:(BOOL)animated**的时候调用其父类的相应函数，因此navigation bar的外观设置会出错。</p>
<p><strong>解法</strong></p>
<p>如果你自己实现了UIViewController生命周期相关函数，那么需要在该函数最开始调用其父类的相应函数。</p>
<h3 id="2NSNotification问题"><a href="#2NSNotification问题" class="headerlink" title="2NSNotification问题"></a>2NSNotification问题</h3><p><strong>背景</strong></p>
<p>NSNotification是iOS上多种事件通知机制的一种。常用于一对多的通知。</p>
<p>BaseViewController在处理非当前展示控制器收到的内存警告的时候总会把self.view设置为nil。代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)didReceiveMemoryWarning &#123;</span><br><span class="line">  [<span class="keyword">super</span> didReceiveMemoryWarning];</span><br><span class="line">  <span class="keyword">if</span> ([[<span class="built_in">UIDevice</span> currentDevice].systemVersion floatValue] &gt;= <span class="number">6.0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isViewLoaded &amp;&amp; !<span class="keyword">self</span>.view.window) &#123;</span><br><span class="line">      <span class="keyword">self</span>.view = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>现象</strong></p>
<p>某次发现，MyViewController收到@”FooNotification”通知时会多次调用*<em>- (void)p_onFooNotification:(NSNotification <em>)notify</em></em>函数。代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyViewController</span> : <span class="title">BaseViewController</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                             selector:<span class="keyword">@selector</span>(p_onFooNotification:)</span><br><span class="line">                                                 name:<span class="string">@&quot;FooNotification&quot;</span></span><br><span class="line">                                               object:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">//其他代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)p_onFooNotification:(<span class="built_in">NSNotification</span> *)notify &#123;</span><br><span class="line">    <span class="comment">//其他代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p><strong>解释</strong></p>
<p>某次收到了内存警告，MyViewController正好不在界面上，（是底部controller）。BaseViewController的*<em>- (void)didReceiveMemoryWarning<strong>会将self.view设置为nil。下次MyViewController显示的时候会再调用一次</strong>- (void)viewDidLoad<strong>。这时又添加了一次@”FooNotification”通知的观察。所以通知一旦发出，</strong>- (void)p_onFooNotification:(NSNotification <em>)notify</em></em>函数会被调用多次。</p>
<p><strong>解法</strong></p>
<p>1）了解**- (void)viewDidLoad**函数可能会被调用多次，只要self.view 是nil。在controller显示出来的时候就会调用该函数；</p>
<p>2）在controller中添加对通知的观察最好不要放在**- (void)viewDidLoad<strong>函数中；推荐做法是在</strong>- (void)viewDidAppear:(BOOL)animated<strong>中添加对通知的观察，</strong>- (void)viewDidDisappear:(BOOL)animated**中移除对通知的观察。例如<a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/21619962/nsnotification-errors">NSNotification errors</a>所作的解答。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/05/04/2015-05-03-BlocksKit%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/img/common/avatar.jpg">
      <meta itemprop="name" content="宿于松下">
      <meta itemprop="description" content="行有不得反求诸己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="宿于松下的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2015/05/04/2015-05-03-BlocksKit%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">BlocksKit源码分析（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2015-05-04T00:00:00+08:00">2015-05-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-15 17:11:41" itemprop="dateModified" datetime="2021-08-15T17:11:41+08:00">2021-08-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">iOS源码分析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1引言"><a href="#1引言" class="headerlink" title="1引言"></a>1引言</h2><p>众所周知Block已被广泛用于iOS编程。它们通常被用作可并发执行的逻辑单元的封装，或者作为事件触发的回调。Block比传统回调函数有2点优势：</p>
<ol>
<li><strong>允许在调用点上下文书写执行逻辑，不用分离函数</strong></li>
<li><strong>Block可以使用local variables.</strong></li>
</ol>
<p>基于以上种种优点Cocoa Touch越发支持Block式编程，这点从UIView的各种动画效果可用Block实现就可见一斑。而BlocksKit是对Cocoa Touch Block编程更进一步的支持，它简化了Block编程，发挥Block的相关优势，让更多UIKit类支持Block式编程。</p>
<h2 id="2BlocksKit目录结构"><a href="#2BlocksKit目录结构" class="headerlink" title="2BlocksKit目录结构"></a>2BlocksKit目录结构</h2><p>BlocksKit代码存放在4个目录中分别是Core、DynamicDelegate、MessageUI、UIKit。其中：</p>
<ul>
<li><strong>Core</strong> 存放Foundation Kit相关的Block category</li>
<li><strong>DynamicDelegate</strong> 动态代理（一种事件转发机制）相关代码</li>
<li><strong>MessageUI</strong> 存放MessageUI相关的Block category</li>
<li><strong>UIKit</strong> 存放UIKit相关的Block category</li>
</ul>
<p>本文尝试去梳理BlocksKit的实现方式并列举BlocksKit使用的例子。</p>
<h2 id="3Core相关代码分析和举例"><a href="#3Core相关代码分析和举例" class="headerlink" title="3Core相关代码分析和举例"></a>3Core相关代码分析和举例</h2><p>Core文件夹下面的代码可以分为如下几个部分：</p>
<ol>
<li><strong>容器相关</strong>（NSArray、NSDictionary、NSSet、NSIndexSet、NSMutableArray、NSMutableDictionary、NSMutableSet、NSMutableIndexSet）</li>
<li><strong>关联对象相关</strong></li>
<li><strong>逻辑执行相关</strong></li>
<li><strong>KVO相关</strong></li>
<li><strong>定时器相关</strong></li>
</ol>
<h3 id="3-1容器相关的BlocksKit"><a href="#3-1容器相关的BlocksKit" class="headerlink" title="3.1容器相关的BlocksKit"></a>3.1容器相关的BlocksKit</h3><p>不管是可变容器还是不可变容器，容器相关的BlocksKit代码总体上说是对容器原生block相关函数的封装。容器相关的BlocksKit函数更加接近自然语义，有一种函数式编程和语义编程的感觉。</p>
<p>以下给出部分不可变容器的BlocksKit声明：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//串行遍历容器中所有元素</span></span><br><span class="line">- (<span class="keyword">void</span>)bk_each:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> obj))block; </span><br><span class="line"><span class="comment">//并发遍历容器中所有元素（不要求容器中元素顺次遍历的时候可以使用此种遍历方式来提高遍历速度）</span></span><br><span class="line">- (<span class="keyword">void</span>)bk_apply:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> obj))block;</span><br><span class="line"><span class="comment">//返回第一个符合block条件（让block返回YES）的对象</span></span><br><span class="line">- (<span class="keyword">id</span>)bk_match:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> obj))block;</span><br><span class="line"><span class="comment">//返回所有符合block条件（让block返回YES）的对象</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)bk_select:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> obj))block;</span><br><span class="line"><span class="comment">//返回所有！！！不符合block条件（让block返回YES）的对象</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)bk_reject:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> obj))block;</span><br><span class="line"><span class="comment">//返回对象的block映射数组</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)bk_map:(<span class="keyword">id</span> (^)(<span class="keyword">id</span> obj))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看容器是否有符合block条件的对象</span></span><br><span class="line"><span class="comment">//判断是否容器中至少有一个元素符合block条件</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)bk_any:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> obj))block; </span><br><span class="line"><span class="comment">//判断是否容器中所有元素都！！！不符合block条件</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)bk_none:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> obj))block;</span><br><span class="line"><span class="comment">//判断是否容器中所有元素都符合block条件</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)bk_all:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> obj))block;</span><br></pre></td></tr></table></figure>

<p>其中bk_all函数的实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)bk_all:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> obj))block</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(block != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    __block <span class="built_in">BOOL</span> result = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> enumerateObjectsUsingBlock:^(<span class="keyword">id</span> obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!block(obj)) &#123;</span><br><span class="line">            result = <span class="literal">NO</span>;</span><br><span class="line">            *stop = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从以上各种函数声明以及bk_all函数的定义我们就可以看出，容器相关的BlocksKit函数确实更加接近自然语义，简化编程。</p>
<p>再给出部分不可变容器的BlocksKit声明：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Filters a mutable array to the objects matching the block.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param block A single-argument, BOOL-returning code block.</span></span><br><span class="line"><span class="comment"> @see &lt;NSArray(BlocksKit)&gt;bk_reject:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//删除容器中!!!不符合block条件的对象，即只保留符合block条件的对象</span></span><br><span class="line">- (<span class="keyword">void</span>)bk_performSelect:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> obj))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除容器中符合block条件的对象</span></span><br><span class="line">- (<span class="keyword">void</span>)bk_performReject:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> obj))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">//容器中的对象变换为自己的block映射对象</span></span><br><span class="line">- (<span class="keyword">void</span>)bk_performMap:(<span class="keyword">id</span> (^)(<span class="keyword">id</span> obj))block;</span><br></pre></td></tr></table></figure>

<h3 id="3-2关联对象相关的BlocksKit"><a href="#3-2关联对象相关的BlocksKit" class="headerlink" title="3.2关联对象相关的BlocksKit"></a>3.2关联对象相关的BlocksKit</h3><p>关联对象的作用如下：<br>在类的定义之外为类增加额外的存储空间。使用关联，我们可以不用修改类的定义而为其对象增加存储空间。这在我们无法访问到类的源码的时候或者是考虑到二进制兼容性的时候是非常有用。关联是基于关键字的，因此，我们可以为任何对象增加任意多的关联，每个都使用不同的关键字即可。关联是可以保证被关联的对象在关联对象的整个生命周期都是可用的（ARC下也不会导致资源不可回收）。<a target="_blank" rel="noopener" href="http://blog.csdn.net/onlyou930/article/details/9299169">关联对象的例子</a> </p>
<p>在我们的实际项目中的常见用法一般有category中用关联对象定义property，或者使用关联对象绑定一个block。</p>
<p>关联对象相关的BlocksKit是对objc_setAssociatedObject、objc_getAssociatedObject、objc_removeAssociatedObjects这几个原生关联对象函数的封装。主要是封装其其内存管理语义。</p>
<p>部分函数声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@interface NSObject (BKAssociatedObjects)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以OBJC_ASSOCIATION_RETAIN_NONATOMIC方式绑定关联对象</span></span><br><span class="line">- (<span class="keyword">void</span>)bk_associateValue:(<span class="keyword">id</span>)value withKey:(<span class="keyword">const</span> <span class="keyword">void</span> *)key;</span><br><span class="line"><span class="comment">//以OBJC_ASSOCIATION_COPY_NONATOMIC方式绑定关联对象</span></span><br><span class="line">- (<span class="keyword">void</span>)bk_associateCopyOfValue:(<span class="keyword">id</span>)value withKey:(<span class="keyword">const</span> <span class="keyword">void</span> *)key;</span><br><span class="line"><span class="comment">//以OBJC_ASSOCIATION_RETAIN方式绑定关联对象</span></span><br><span class="line">- (<span class="keyword">void</span>)bk_atomicallyAssociateValue:(<span class="keyword">id</span>)value withKey:(<span class="keyword">const</span> <span class="keyword">void</span> *)key;</span><br><span class="line"><span class="comment">//以OBJC_ASSOCIATION_COPY方式绑定关联对象</span></span><br><span class="line">- (<span class="keyword">void</span>)bk_atomicallyAssociateCopyOfValue:(<span class="keyword">id</span>)value withKey:(<span class="keyword">const</span> <span class="keyword">void</span> *)key;</span><br><span class="line"><span class="comment">//弱绑定</span></span><br><span class="line">- (<span class="keyword">void</span>)bk_weaklyAssociateValue:(__autoreleasing <span class="keyword">id</span>)value withKey:(<span class="keyword">const</span> <span class="keyword">void</span> *)key;</span><br><span class="line"><span class="comment">//删除所有绑定的关联对象</span></span><br><span class="line">- (<span class="keyword">void</span>)bk_removeAllAssociatedObjects;</span><br></pre></td></tr></table></figure>

<p>除了<em>弱绑定</em>以外，其它BlocksKit函数都是简单封装。只有弱绑定看起来挺牛B，有点扩展关联对象原生语义的感觉。</p>
<p>弱绑定实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_BKWeakAssociatedObject</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)bk_weaklyAssociateValue:(__autoreleasing <span class="keyword">id</span>)value withKey:(<span class="keyword">const</span> <span class="keyword">void</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    _BKWeakAssociatedObject *assoc = objc_getAssociatedObject(<span class="keyword">self</span>, key);</span><br><span class="line">    <span class="keyword">if</span> (!assoc) &#123;</span><br><span class="line">        assoc = [_BKWeakAssociatedObject new];</span><br><span class="line">        <span class="comment">//做一个_BKWeakAssociatedObject对象中间层</span></span><br><span class="line">        <span class="comment">//以非原子持有的方式绑定一个_BKWeakAssociatedObject对象</span></span><br><span class="line">        <span class="comment">//_BKWeakAssociatedObject该对象又有真实对象的弱引用</span></span><br><span class="line">        [<span class="keyword">self</span> bk_associateValue:assoc withKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//_BKWeakAssociatedObject的weak property设置为真正应该关联的对象</span></span><br><span class="line">    assoc.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从以上实现代码可以看出，所谓弱绑定实际上是在关联对象之间做了一个中间层，让本对象以OBJC_ASSOCIATION_RETAIN_NONATOMIC的形式去关联中间层（_BKWeakAssociatedObject），而中间层又以weak property的形式去存储真正关联对象的指针。</p>
<h3 id="3-3逻辑执行相关的BlocksKit"><a href="#3-3逻辑执行相关的BlocksKit" class="headerlink" title="3.3逻辑执行相关的BlocksKit"></a>3.3逻辑执行相关的BlocksKit</h3><p>所谓逻辑执行，就是Block块执行。逻辑执行相关的BlocksKit是对dispatch_after函数的封装。使其更加符合语义。</p>
<p>主要函数如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@interface NSObject (BKBlockExecution)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//主线程执行block方法，延迟时间可选</span></span><br><span class="line">- (<span class="keyword">id</span>)bk_performBlock:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> obj))block afterDelay:(<span class="built_in">NSTimeInterval</span>)delay</span><br><span class="line"><span class="comment">//后台线程执行block方法，延迟时间可选</span></span><br><span class="line">- (<span class="keyword">id</span>)bk_performBlockInBackground:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> obj))block afterDelay:(<span class="built_in">NSTimeInterval</span>)delay</span><br><span class="line"></span><br><span class="line"><span class="comment">//所有执行block相关的方法都是此方法的简化版，该函数在指定的block队列上以指定的时间延迟执行block</span></span><br><span class="line">- (<span class="keyword">id</span>)bk_performBlock:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> obj))block onQueue:(<span class="built_in">dispatch_queue_t</span>)queue afterDelay:(<span class="built_in">NSTimeInterval</span>)delay;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消block，非常牛逼！！！一般来说一个block加到block queue上是没法取消的，此方法实现了block的取消操作（必须是用BlocksKit投放的block）</span></span><br><span class="line">+ (<span class="keyword">void</span>)bk_cancelBlock:(<span class="keyword">id</span>)block;</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)bk_performBlock:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> obj))block onQueue:(<span class="built_in">dispatch_queue_t</span>)queue afterDelay:(<span class="built_in">NSTimeInterval</span>)delay</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(block != <span class="literal">nil</span>);</span><br><span class="line">    <span class="comment">//cancelled是个__block变量，使得该block在加入queue后能够逻辑上取消。注意，仅仅是逻辑上取消，不能把block从queue中剔除。</span></span><br><span class="line">    __block <span class="built_in">BOOL</span> cancelled = <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在外部block之上加一层能够逻辑取消的代码，使其变为一个wrapper block</span></span><br><span class="line">    <span class="comment">//当调用wrapper(YES)的时候就让__block BOOL cancelled = YES,使得以后每次block主体都被跳过。</span></span><br><span class="line">    <span class="keyword">void</span> (^wrapper)(<span class="built_in">BOOL</span>) = ^(<span class="built_in">BOOL</span> cancel) &#123;</span><br><span class="line">    <span class="comment">//cancel参数是为了在外部能够控制cancelled _block变量</span></span><br><span class="line">        <span class="keyword">if</span> (cancel) &#123;</span><br><span class="line">            cancelled = <span class="literal">YES</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!cancelled) block(<span class="keyword">self</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//每个投入queue中的block实际上是wraper版的block</span></span><br><span class="line">    dispatch_after(BKTimeDelay(delay), queue, ^&#123;</span><br><span class="line">        <span class="comment">//把cancel设置为NO,block能够逻辑执行</span></span><br><span class="line">        wrapper(<span class="literal">NO</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回wraper block，以便bk_cancelBlock的时候使用</span></span><br><span class="line">    <span class="keyword">return</span> [wrapper <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)bk_cancelBlock:(<span class="keyword">id</span>)block</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(block != <span class="literal">nil</span>);</span><br><span class="line">    <span class="keyword">void</span> (^wrapper)(<span class="built_in">BOOL</span>) = block;</span><br><span class="line">    <span class="comment">//把cancel设置为YES,修改block中_block cancelled变量，如果此时block未执行则，block在执行的时候其逻辑主体会被跳过</span></span><br><span class="line">    wrapper(<span class="literal">YES</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码给出了bk_performBlock和bk_cancelBlock的实现。其中bk_performBlock对参数block进行一层封装后再用dispatch_after投入相应的queue。注意该函数会返回的wrapper block，以供cancel。</p>
<h3 id="3-4KVO相关BlocksKit"><a href="#3-4KVO相关BlocksKit" class="headerlink" title="3.4KVO相关BlocksKit"></a>3.4KVO相关BlocksKit</h3><p>KVO主要涉及两类对象，即“被观察对象“和“观察者“。</p>
<p>与“被观察对象”相关的函数主要有如下两个：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加观察者</span></span><br><span class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath options:(<span class="built_in">NSKeyValueObservingOptions</span>)options context:(<span class="keyword">void</span> *)context;</span><br><span class="line"><span class="comment">//删除观察者</span></span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath context:(<span class="keyword">void</span> *)context;</span><br></pre></td></tr></table></figure>

<p>与“观察者“相关的函数如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//观察到对象发生变化后的回调函数（观察回调）</span></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context;</span><br></pre></td></tr></table></figure>

<p>通常的KVO做法是先对“被观察对象”添加“观察者”，同时在“观察者”中实现观察回调。这样每当“被观察对象”的指定property改变时，“观察者”就会调用观察回调。</p>
<p>KVO相关BlocksKit弱化了“观察者”这种对象，使得每当“被观察对象”的指定property改变时，就会调起一个block。具体实现方式是定义一个_BKObserver类，让该类实现观察回调、对被观察对象添加观察者和删除观察者。</p>
<p>_BKObserver类定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_BKObserver</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="built_in">BOOL</span> _isObserving;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储“被观察的对象”</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">unsafe_unretained</span>) <span class="keyword">id</span> observee;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSMutableArray</span> *keyPaths;</span><br><span class="line"><span class="comment">//存储回调block</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">id</span> task;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) BKObserverContext context;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)initWithObservee:(<span class="keyword">id</span>)observee keyPaths:(<span class="built_in">NSArray</span> *)keyPaths context:(BKObserverContext)context task:(<span class="keyword">id</span>)task;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *BKObserverBlocksKey = &amp;BKObserverBlocksKey;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *BKBlockObservationContext = &amp;BKBlockObservationContext;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">_BKObserver</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)initWithObservee:(<span class="keyword">id</span>)observee keyPaths:(<span class="built_in">NSArray</span> *)keyPaths context:(BKObserverContext)context task:(<span class="keyword">id</span>)task</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</span><br><span class="line">        _observee = observee;</span><br><span class="line">        _keyPaths = [keyPaths mutableCopy];</span><br><span class="line">        _context = context;</span><br><span class="line">        _task = [task <span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//观察者回调，在KV改变的时候调用相关block</span></span><br><span class="line">    <span class="keyword">if</span> (context != BKBlockObservationContext) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">self</span>.context) &#123;</span><br><span class="line">            <span class="keyword">case</span> BKObserverContextKey: &#123;</span><br><span class="line">                <span class="keyword">void</span> (^task)(<span class="keyword">id</span>) = <span class="keyword">self</span>.task;</span><br><span class="line">                task(object);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> BKObserverContextKeyWithChange: &#123;</span><br><span class="line">                <span class="keyword">void</span> (^task)(<span class="keyword">id</span>, <span class="built_in">NSDictionary</span> *) = <span class="keyword">self</span>.task;</span><br><span class="line">                task(object, change);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> BKObserverContextManyKeys: &#123;</span><br><span class="line">                <span class="keyword">void</span> (^task)(<span class="keyword">id</span>, <span class="built_in">NSString</span> *) = <span class="keyword">self</span>.task;</span><br><span class="line">                task(object, keyPath);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> BKObserverContextManyKeysWithChange: &#123;</span><br><span class="line">                <span class="keyword">void</span> (^task)(<span class="keyword">id</span>, <span class="built_in">NSString</span> *, <span class="built_in">NSDictionary</span> *) = <span class="keyword">self</span>.task;</span><br><span class="line">                task(object, keyPath, change);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启KV观察</span></span><br><span class="line">- (<span class="keyword">void</span>)startObservingWithOptions:(<span class="built_in">NSKeyValueObservingOptions</span>)options</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_isObserving) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        [<span class="keyword">self</span>.keyPaths bk_each:^(<span class="built_in">NSString</span> *keyPath) &#123;</span><br><span class="line">        <span class="comment">//observee的被观察对象，observer是自己，</span></span><br><span class="line">            [<span class="keyword">self</span>.observee addObserver:<span class="keyword">self</span> forKeyPath:keyPath options:options context:BKBlockObservationContext];</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">        _isObserving = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//停止KV观察</span></span><br><span class="line">- (<span class="keyword">void</span>)stopObservingKeyPath:(<span class="built_in">NSString</span> *)keyPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(keyPath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_isObserving) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (![<span class="keyword">self</span>.keyPaths containsObject:keyPath]) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSObject</span> *observee = <span class="keyword">self</span>.observee;</span><br><span class="line">        <span class="keyword">if</span> (!observee) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        [<span class="keyword">self</span>.keyPaths removeObject: keyPath];</span><br><span class="line">        keyPath = [keyPath <span class="keyword">copy</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.keyPaths.count) &#123;</span><br><span class="line">            _task = <span class="literal">nil</span>;</span><br><span class="line">            _observee = <span class="literal">nil</span>;</span><br><span class="line">            _keyPaths = <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [observee removeObserver:<span class="keyword">self</span> forKeyPath:keyPath context:BKBlockObservationContext];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体添加删除KVO block的函数实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加观察block</span></span><br><span class="line">- (<span class="keyword">void</span>)bk_addObserverForKeyPaths:(<span class="built_in">NSArray</span> *)keyPaths identifier:(<span class="built_in">NSString</span> *)identifier options:(<span class="built_in">NSKeyValueObservingOptions</span>)options context:(BKObserverContext)context task:(<span class="keyword">id</span>)task</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(keyPaths.count);</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(identifier.length);</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(task);</span><br><span class="line"></span><br><span class="line">    Class classToSwizzle = <span class="keyword">self</span>.class;</span><br><span class="line">    <span class="built_in">NSMutableSet</span> *classes = <span class="keyword">self</span>.class.bk_observedClassesHash;</span><br><span class="line">    <span class="keyword">@synchronized</span> (classes) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *className = <span class="built_in">NSStringFromClass</span>(classToSwizzle);</span><br><span class="line">        <span class="keyword">if</span> (![classes containsObject:className]) &#123;</span><br><span class="line">            SEL deallocSelector = sel_registerName(<span class="string">&quot;dealloc&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            __block <span class="keyword">void</span> (*originalDealloc)(__<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span>, SEL) = <span class="literal">NULL</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//勾住类的dealloc方法，并且在其中添加bk_removeAllBlockObservers方法</span></span><br><span class="line">            <span class="keyword">id</span> newDealloc = ^(__<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> objSelf) &#123;</span><br><span class="line">                [objSelf bk_removeAllBlockObservers];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (originalDealloc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="keyword">struct</span> objc_super superInfo = &#123;</span><br><span class="line">                        .receiver = objSelf,</span><br><span class="line">                        .super_class = class_getSuperclass(classToSwizzle)</span><br><span class="line">                    &#125;;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">void</span> (*msgSend)(<span class="keyword">struct</span> objc_super *, SEL) = (__typeof__(msgSend))objc_msgSendSuper;</span><br><span class="line">                    msgSend(&amp;superInfo, deallocSelector);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    originalDealloc(objSelf, deallocSelector);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            IMP newDeallocIMP = imp_implementationWithBlock(newDealloc);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!class_addMethod(classToSwizzle, deallocSelector, newDeallocIMP, <span class="string">&quot;v@:&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// The class already contains a method implementation.</span></span><br><span class="line">                Method deallocMethod = class_getInstanceMethod(classToSwizzle, deallocSelector);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// We need to store original implementation before setting new implementation</span></span><br><span class="line">                <span class="comment">// in case method is called at the time of setting.</span></span><br><span class="line">                originalDealloc = (<span class="keyword">void</span>(*)(__<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span>, SEL))method_getImplementation(deallocMethod);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// We need to store original implementation again, in case it just changed.</span></span><br><span class="line">                originalDealloc = (<span class="keyword">void</span>(*)(__<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span>, SEL))method_setImplementation(deallocMethod, newDeallocIMP);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            [classes addObject:className];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//生成_BKObserver对象（真正的KV Observer）</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *dict;</span><br><span class="line">    _BKObserver *observer = [[_BKObserver alloc] initWithObservee:<span class="keyword">self</span> keyPaths:keyPaths context:context task:task];</span><br><span class="line">    <span class="comment">//启动观察</span></span><br><span class="line">    [observer startObservingWithOptions:options];</span><br><span class="line"></span><br><span class="line">   <span class="comment">//将新生成的_BKObserver对象添加到dic中</span></span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        dict = [<span class="keyword">self</span> bk_observerBlocks];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dict == <span class="literal">nil</span>) &#123;</span><br><span class="line">            dict = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">            [<span class="keyword">self</span> bk_setObserverBlocks:dict];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dict[identifier] = observer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除观察block</span></span><br><span class="line">- (<span class="keyword">void</span>)bk_removeAllBlockObservers</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *dict;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        dict = [[<span class="keyword">self</span> bk_observerBlocks] <span class="keyword">copy</span>];</span><br><span class="line">        [<span class="keyword">self</span> bk_setObserverBlocks:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [dict.allValues bk_each:^(_BKObserver *trampoline) &#123;</span><br><span class="line">        [trampoline stopObserving];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5定时器相关BlocksKit"><a href="#3-5定时器相关BlocksKit" class="headerlink" title="3.5定时器相关BlocksKit"></a>3.5定时器相关BlocksKit</h3><p>NSTimer有个比较恶心的特性，它会持有它的target。比如在一个controller中使用了timer，并且timer的target设置为该controller本身，那么想在controller的dealloc中fire掉timer是做不到的，必须要在其他的地方fire。这会让编码很难受。具体参考《Effective Objective C》的最后一条。 BlocksKit解除这种恶心，其方式是把timer的target设置为timer 的class对象。把要执行的block保存在timer的userInfo中执行。因为timer 的class对象一直存在，所以是否被持有其实无所谓。</p>
<p>实现代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>)bk_scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)inTimeInterval block:(<span class="keyword">void</span> (^)(<span class="built_in">NSTimer</span> *timer))block repeats:(<span class="built_in">BOOL</span>)inRepeats</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(block != <span class="literal">nil</span>);</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> scheduledTimerWithTimeInterval:inTimeInterval target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(bk_executeBlockFromTimer:) userInfo:[block <span class="keyword">copy</span>] repeats:inRepeats];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>)bk_timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)inTimeInterval block:(<span class="keyword">void</span> (^)(<span class="built_in">NSTimer</span> *timer))block repeats:(<span class="built_in">BOOL</span>)inRepeats</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(block != <span class="literal">nil</span>);</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> timerWithTimeInterval:inTimeInterval target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(bk_executeBlockFromTimer:) userInfo:[block <span class="keyword">copy</span>] repeats:inRepeats];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)bk_executeBlockFromTimer:(<span class="built_in">NSTimer</span> *)aTimer &#123;</span><br><span class="line">    <span class="keyword">void</span> (^block)(<span class="built_in">NSTimer</span> *) = [aTimer userInfo];</span><br><span class="line">    <span class="keyword">if</span> (block) block(aTimer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4BlocksKit源码分析（一）小结"><a href="#4BlocksKit源码分析（一）小结" class="headerlink" title="4BlocksKit源码分析（一）小结"></a>4BlocksKit源码分析（一）小结</h2><p>本文介绍了BlocksKit源码的组织结构：Core、DynamicDelegate、MessageUI、UIKit。并简要分析了Core的源码。该部分代码由5个小部分组成：容器、关联对象、逻辑执行、KVO、定时器。由源码可以看出BlocksKit扩展更加符合自然语义，如容器相关代码；BlocksKit一般通过中间层来承载回调函数，并在中间层回调的时候调用相应block，如KVO的BlocksKit实现。总体来说，Core代码是这些代码的最基础部分，具有很强的通用性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/05/04/2015-05-04-BlocksKit%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/img/common/avatar.jpg">
      <meta itemprop="name" content="宿于松下">
      <meta itemprop="description" content="行有不得反求诸己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="宿于松下的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2015/05/04/2015-05-04-BlocksKit%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">BlocksKit源码分析（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2015-05-04T00:00:00+08:00">2015-05-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-15 17:11:41" itemprop="dateModified" datetime="2021-08-15T17:11:41+08:00">2021-08-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">iOS源码分析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1引言"><a href="#1引言" class="headerlink" title="1引言"></a>1引言</h2><p>在<strong>《BlocksKit源码分析（一）》</strong>中我们分析了BlocksKit源码组织结构以及第一部分Core的源码。在这里我们接着分析BlocksKit第二部分——DynamicDelegate（动态代理）。所谓动态代理，听起来挺玄乎。实际一言以蔽之，就是把delegate转为block的手段。</p>
<h2 id="2动态代理样例"><a href="#2动态代理样例" class="headerlink" title="2动态代理样例"></a>2动态代理样例</h2><p>我们先从一个例子来看看动态代理的使用方式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>) annoyUser</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建一个alert view</span></span><br><span class="line">    <span class="built_in">UIAlertView</span> *alertView = [[<span class="built_in">UIAlertView</span> alloc]</span><br><span class="line">                              initWithTitle:<span class="string">@&quot;Hello World!&quot;</span></span><br><span class="line">                              message:<span class="string">@&quot;This alert&#x27;s delegate is implemented using blocks. That&#x27;s so cool!&quot;</span></span><br><span class="line">                              delegate:<span class="literal">nil</span></span><br><span class="line">                              cancelButtonTitle:<span class="string">@&quot;Meh.&quot;</span></span><br><span class="line">                              otherButtonTitles:<span class="string">@&quot;Woo!&quot;</span>, <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取该alert view的动态代理对象（什么是动态代理对象稍后会说）</span></span><br><span class="line">    A2DynamicDelegate *dd = alertView.bk_dynamicDelegate;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用动态代理对象的 - (void)implementMethod:(SEL)selector withBlock:(id)block;方法，使得SEL映射一个block对象(假设叫做block1)</span></span><br><span class="line">    [dd implementMethod:<span class="keyword">@selector</span>(alertViewShouldEnableFirstOtherButton:) withBlock:^(<span class="built_in">UIAlertView</span> *alertView) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Message: %@&quot;</span>, alertView.message);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同上，让映射-alertView:willDismissWithButtonIndex:的SEL到另外一个block对象(假设叫做block2)</span></span><br><span class="line">    [dd implementMethod:<span class="keyword">@selector</span>(alertView:willDismissWithButtonIndex:) withBlock:^(<span class="built_in">UIAlertView</span> *alertView, <span class="built_in">NSInteger</span> buttonIndex) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;You pushed button #%d (%@)&quot;</span>, buttonIndex, [alertView buttonTitleAtIndex:buttonIndex]);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把alertView的delegate设置为动态代理</span></span><br><span class="line">    alertView.delegate = dd;</span><br><span class="line">    </span><br><span class="line">    [alertView show];</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 那么，alert view在显示的时候收到alertViewShouldEnableFirstOtherButton:消息调用block1；alert view在消失的时候收到alertView:willDismissWithButtonIndex:消息，调用block2</span></span><br></pre></td></tr></table></figure>

<p>从上面的代码我们可以直观地看到：dd（动态代理对象）直接被设置为alert view的delegate对象，那么该alert view的UIAlertViewDelegate消息直接传递向给了dd。然后dd又通过某种方式把对应的SEL调用转为对应的block调用。我们又可以作出如下猜测：</p>
<ol>
<li>dd内部可能有个dic一样的数据结构，key可能是SEL，value可能是与之对应的block，通过implementMethod:withBlock:这个方法把SEL和block以键值对的形式建立起dic映射</li>
<li>Host对象（本例是alertView）向dd发delegate消息的时候传递了SEL，dd在内部的dic数据结构查找对应的block，找到后，调用该block。</li>
</ol>
<p>基本思路是这样的，but还有两个问题需要解决：</p>
<ol>
<li>dd（动态代理对象）是如何创建的？</li>
<li>如UIAlertViewDelegate这样的各种delegate有不同的消息，任意一个消息都可能发给dd，dd是如何能接受任意消息的，显然实现每个消息是不现实的。</li>
</ol>
<h2 id="3消息转发机制"><a href="#3消息转发机制" class="headerlink" title="3消息转发机制"></a>3消息转发机制</h2><p>我们先来回答第二个问题，即动态代理是如何能接受任意消息的。<br> 当一个object收到它没实现的消息的时候，通常会发生如下的情况。</p>
<ol>
<li><p>首先看是否为该 selector 提供了动态方法决议机制,如果提供了则转到2;如果没有提供则转到3;</p>
</li>
<li><p>如果动态方法决议真正为该 selector 提供了实现,那么就调用该实现,完成消息发送流程,消息转发就不会进行了;如果没有提供,则转到 3;</p>
</li>
<li><p>其次看是否为该 selector 提供了消息转发机制,如果提供了消息了则进行消息转发,此时,无论消息 转发是怎样实现的,程序均不会 crash。(因为消息调用的控制权完全交给消息转发机制处理,即使消息转发并没有做任何事情,运行也不会有错误,编译器更不会有错误提示。);如果没提供消息转发机制, 则转到 4;</p>
</li>
<li><p>运行报错:无法识别的 selector,程序 crash;</p>
<p>通过以上描述我们可以知道。dd（A2DynamicDelegate类）支持任意消息发送，不是用了消息决议就是用了消息转发。实际上通过代码我们可以看出 A2DynamicDelegate是继承自NSProxy类，该类是专门做消息转发的。继承自该类的类必须要实现- (void)forwardInvocation:(NSInvocation *)outerInv方法。因为该方法是当该类的对象收到无法识别的消息的时候调用的方法。所以dd消息映射流程大概是这样的：当dd收到无法识别的消息时会调用forwardInvocation，该函数的参数outerInv可以拿到对应消息的SEL,再通过SEL在再内部的dic里面找到对应的block进行调用。（简要思路）</p>
</li>
</ol>
<h2 id="4动态代理对象的创建"><a href="#4动态代理对象的创建" class="headerlink" title="4动态代理对象的创建"></a>4动态代理对象的创建</h2><p>A2DynamicDelegate这种对象是如何创建的？为什么从代码里面看dd（A2DynamicDelegate）好像是alertView的一个property。<br> 实际上dd是通过NSObject的(A2DynamicDelegate)分类来实现的。该分类用关联对象的方法，把protocal和A2DynamicDelegate对象关联起来。使得相应的protocal有对应的A2DynamicDelegate对象。某个类的bk_dynamicDelegate实际上是查找该类对应delegate的protocal，再根据这个protocal找到对应的A2DynamicDelegate对象。如果找不到A2DynamicDelegate对象就创建一个关联起来。比如alertView.bk_dynamicDelegate;会查找alertView的delegate UIAlertViewDelegate protocal所关联的对象，如果没有找到就创建一个，并且做关联。<br> 相关代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// File:NSObject+A2DynamicDelegate.m</span></span><br><span class="line"> - (<span class="keyword">id</span>)bk_dynamicDelegateWithClass:(Class)cls forProtocol:(Protocol *)protocol</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Storing the dynamic delegate as an associated object of the delegating</span></span><br><span class="line"><span class="comment">     * object not only allows us to later retrieve the delegate, but it also</span></span><br><span class="line"><span class="comment">     * creates a strong relationship to the delegate. Since delegates are weak</span></span><br><span class="line"><span class="comment">     * references on the part of the delegating object, a dynamic delegate</span></span><br><span class="line"><span class="comment">     * would be deallocated immediately after its declaring scope ends.</span></span><br><span class="line"><span class="comment">     * Therefore, this strong relationship is required to ensure that the</span></span><br><span class="line"><span class="comment">     * delegate&#x27;s lifetime is at least as long as that of the delegating object.</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line"></span><br><span class="line">    __block A2DynamicDelegate *dynamicDelegate;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(a2_backgroundQueue(), ^&#123;</span><br><span class="line">        dynamicDelegate = objc_getAssociatedObject(<span class="keyword">self</span>, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)protocol);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!dynamicDelegate)</span><br><span class="line">        &#123;</span><br><span class="line">            dynamicDelegate = [[cls alloc] initWithProtocol:protocol];</span><br><span class="line">            objc_setAssociatedObject(<span class="keyword">self</span>, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)protocol, dynamicDelegate, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dynamicDelegate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5代码设计"><a href="#5代码设计" class="headerlink" title="5代码设计"></a>5代码设计</h2><p>A2DynamicDelegate是动态代理类，NSObject_A2DynamicDelegate是NSObject分类用来创建动态代理对象。A2BlockInvocation这个类我们之前没有说过，它是block的一层封装。A2DynamicDelegate里面的字典数据结构装得不是纯粹的block，而是A2BlockInvocation对象。</p>
<p>相关类图如下：<br><img src="/assets/img/postImage/BlocksKit2/1.png" alt="类图"></p>
<p>相关序列图如下：<br><img src="/assets/img/postImage/BlocksKit2/2.png" alt="序列图"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/09/26/2014-09-26-iOS%20Nimbus%E6%A1%86%E6%9E%B6tableview%E9%83%A8%E5%88%86%E8%A7%A3%E8%AF%BB(CSDN%E6%97%A9%E6%9C%9F%E5%8D%9A%E5%AE%A2)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/img/common/avatar.jpg">
      <meta itemprop="name" content="宿于松下">
      <meta itemprop="description" content="行有不得反求诸己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="宿于松下的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2014/09/26/2014-09-26-iOS%20Nimbus%E6%A1%86%E6%9E%B6tableview%E9%83%A8%E5%88%86%E8%A7%A3%E8%AF%BB(CSDN%E6%97%A9%E6%9C%9F%E5%8D%9A%E5%AE%A2)/" class="post-title-link" itemprop="url">iOS Nimbus框架tableview部分解读(CSDN早期博客)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2014-09-26 00:00:00" itemprop="dateCreated datePublished" datetime="2014-09-26T00:00:00+08:00">2014-09-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-15 17:11:41" itemprop="dateModified" datetime="2021-08-15T17:11:41+08:00">2021-08-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>项目中很早就引入了Nimbus框架，一直在搞天气动画，没时间看这个东西。最近要做新的feature，跟table相关。于是花了一下午读了读相关部分的源码。Git上是这么介绍Nimbus的——The iOS framework that grows only as fast as its documentation.一看文档和注释，果然不错，读起来一气呵成，很舒服。</p>
<h3 id="二、整体思路"><a href="#二、整体思路" class="headerlink" title="二、整体思路"></a>二、整体思路</h3><p>众所周知，生成一个UITableView,一般要设置两个东西：dataSource和delegate。其中，dataSource来控制tableview上展示的内容，而delegate用来通知tableview上发生的各种事件，如cell被点击等等。通常我们把这两个委托设置为UITableViewController，让UITableViewController同时实现UITableViewDataSource和UITableViewDelegate protocol。而 Nimbus根据这两个特性造了两个类分别是NITableViewModel（实现UITableViewDataSource，用来设置数据源dataSource）和NITableViewActions（实现UITableViewDelegate，触发tableview上的各种事件）。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//testTableView is a UITableView</span></span><br><span class="line"><span class="comment">//_model is a NITableViewModel instance</span></span><br><span class="line"><span class="comment">//_actions is a NITableViewActions instance</span></span><br><span class="line"><span class="keyword">self</span>.testTableView.delegate = _actions;</span><br><span class="line"><span class="keyword">self</span>.testTableView.dataSource = _model;</span><br></pre></td></tr></table></figure>

<h3 id="三、从数据源到具体Cell"><a href="#三、从数据源到具体Cell" class="headerlink" title="三、从数据源到具体Cell"></a>三、从数据源到具体Cell</h3><p>我们先来看看怎么从数据源生成具体的Cell。Nimbus把该过程分为2部分：数据管理和Cell生成。其中数据管理由NITableViewModel实现，而Cell生成是实现NITableViewModelDelegate protocol，可能有多种方式。</p>
<h4 id="1数据管理"><a href="#1数据管理" class="headerlink" title="1数据管理"></a>1数据管理</h4><p>首先来看看数据管理，NITableViewModel定义。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NITableViewModel</span> : <span class="title">NSObject</span> &lt;<span class="title">UITableViewDataSource</span>&gt;</span></span><br><span class="line">    - (<span class="keyword">id</span>)initWithDelegate:(<span class="keyword">id</span>&lt;NITableViewModelDelegate&gt;)delegate;</span><br><span class="line">    - (<span class="keyword">id</span>)initWithListArray:(<span class="built_in">NSArray</span> *)sectionedArray delegate:(<span class="keyword">id</span>&lt;NITableViewModelDelegate&gt;)delegate;</span><br><span class="line">    - (<span class="keyword">id</span>)initWithSectionedArray:(<span class="built_in">NSArray</span> *)sectionedArray delegate:(<span class="keyword">id</span>&lt;NITableViewModelDelegate&gt;)delegate;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>其中NITableViewModelDelegate，是指定Cell的生成委托，对应第二步，我们先忽略。<br>其中sectionedArray是指定的数据内容。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @code</span></span><br><span class="line"><span class="comment"> * NSArray* contents =</span></span><br><span class="line"><span class="comment"> * [NSArray arrayWithObjects:</span></span><br><span class="line"><span class="comment"> *  @&quot;Section 1&quot;,</span></span><br><span class="line"><span class="comment"> *  [NSDictionary dictionaryWithObject:@&quot;Row 1&quot; forKey:@&quot;title&quot;],</span></span><br><span class="line"><span class="comment"> *  [NSDictionary dictionaryWithObject:@&quot;Row 2&quot; forKey:@&quot;title&quot;],</span></span><br><span class="line"><span class="comment"> *  @&quot;Section 2&quot;,</span></span><br><span class="line"><span class="comment"> *  // This section is empty.</span></span><br><span class="line"><span class="comment"> *  @&quot;Section 3&quot;,</span></span><br><span class="line"><span class="comment"> *  [NSDictionary dictionaryWithObject:@&quot;Row 3&quot; forKey:@&quot;title&quot;],</span></span><br><span class="line"><span class="comment"> *  [NITableViewModelFooter footerWithTitle:@&quot;Footer&quot;],</span></span><br><span class="line"><span class="comment"> *  nil];</span></span><br><span class="line"><span class="comment"> * [[NIStaticTableViewModel alloc] initWithSectionedArray:contents delegate:self];</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>其中调用方式可能如上所示，如果sectionedArray里面的一项是NSString则认为这是一个section头部（标题），如果是一个NITableViewModelFooter对象则认为是一个section的尾部。其余每一项则认为是一个Cell上的内容。如上例，该sectionedArray展示了3个section，第一个section的标题是@”Section 1”,内部有两个cell，具体内容分别由[NSDictionary dictionaryWithObject:@”Row 1” forKey:@”title”]和[NSDictionary dictionaryWithObject:@”Row 2” forKey:@”title”]表示。如此跟table视觉上的排布一致。得到这个sectionedArray后，NITableViewModel对该数组进行一顿解析，在内部用一些更加友好的数据管理起来。我们可以先把NITableViewModel简单的理解为：解析sectionedArray数组，了解里面有哪些section哪些cell，在UITableViewDataSource相应的函数里面返回解析过后的数值。</p>
<h4 id="2Cell生成"><a href="#2Cell生成" class="headerlink" title="2Cell生成"></a>2Cell生成</h4><p>通过上文我们知道，NITableViewModel实现了UITableViewDataSource protocol，该protocol有个一函数用来生成cell的</p>
<p><code>- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;</code></p>
<p>NITableViewModel职责有限，只能管理数据源不管你生成Cell，所以他把这个东西抛给他的委托，NITableViewModelDelegate，让这个委托来生成Cell。我们前文提到生成Cell有多种方式，这些方式都是通过实现NITableViewModelDelegate得来的。<br>UITableViewController实现NITableViewModelDelegate</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableViewModel: (NITableViewModel *)tableViewModel</span><br><span class="line">                   cellForTableView: (<span class="built_in">UITableView</span> *)tableView</span><br><span class="line">                        atIndexPath: (<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">                         withObject: (<span class="keyword">id</span>)object</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> object = [tableViewModel objectAtIndexPath:indexPath];</span><br><span class="line">    <span class="comment">//从数据源获取cell上的数据</span></span><br><span class="line">    <span class="comment">//object就是该cell对应的数据，也就是你在model的sectionedArray里面设置的东西</span></span><br><span class="line">    <span class="comment">//如上例子，若indexPath为section0 row0则object是[NSDictionary dictionaryWithObject:@&quot;Row 1&quot; forKey:@&quot;title&quot;]</span></span><br><span class="line">    <span class="comment">//得到这些信息后，我们再通过平时的策略来生成cell</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用NICellFactory实现NITableViewModelDelegate</p>
<p>若利用此种方式实现Cell生成，则必须要求第一步sectionedArray表示cell内容的对象是一个NICellObject对象。其中NICellObject类定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NICellObject</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line"><span class="comment">/** The class of cell to be created when this object is passed to the cell factory. */</span></span><br><span class="line">- (Class)cellClass;</span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line"><span class="comment">/** The style of UITableViewCell to be used when initializing the cell for the first time. */</span></span><br><span class="line">- (<span class="built_in">UITableViewCellStyle</span>)cellStyle;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NICellObject</span> : <span class="title">NSObject</span> &lt;<span class="title">NICellObject</span>&gt;</span></span><br><span class="line"><span class="comment">// Designated initializer.</span></span><br><span class="line">- (<span class="keyword">id</span>)initWithCellClass:(Class)cellClass userInfo:(<span class="keyword">id</span>)userInfo;</span><br><span class="line">- (<span class="keyword">id</span>)initWithCellClass:(Class)cellClass;</span><br><span class="line">+ (<span class="keyword">id</span>)objectWithCellClass:(Class)cellClass userInfo:(<span class="keyword">id</span>)userInfo;</span><br><span class="line">+ (<span class="keyword">id</span>)objectWithCellClass:(Class)cellClass;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> userInfo;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>通过类定义，我们不难发现，NICellObject实际就是一个带cellClass信息的类，也就是说NICellFactory要求我们传到model的sectionedArray里面的cell内容对象都是带cell class信息的。通过改造，我们可以把indexPath为section0 row0的object变为[NICellObject objectWithCellClass:[UITableViewCell class] userInfo:[NSDictionary dictionaryWithObject:@”Row 1” forKey:@”title”] ];<br>具体生成函数如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">UITableViewCell</span> *)tableViewModel:(NITableViewModel *)tableViewModel</span><br><span class="line">               cellForTableView:(<span class="built_in">UITableView</span> *)tableView</span><br><span class="line">                    atIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">                     withObject:(<span class="keyword">id</span>)object &#123;</span><br><span class="line">  <span class="built_in">UITableViewCell</span>* cell = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Only NICellObject-conformant objects may pass.</span></span><br><span class="line">  <span class="keyword">if</span> ([object respondsToSelector:<span class="keyword">@selector</span>(cellClass)]) &#123;</span><br><span class="line">    <span class="comment">//1拿cellClass</span></span><br><span class="line">    Class cellClass = [object cellClass];</span><br><span class="line">    <span class="comment">//2根据cellClass来生成cell</span></span><br><span class="line">    cell = [<span class="keyword">self</span> cellWithClass:cellClass tableView:tableView object:object];</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([object respondsToSelector:<span class="keyword">@selector</span>(cellNib)]) &#123;</span><br><span class="line">    <span class="built_in">UINib</span>* nib = [object cellNib];</span><br><span class="line">    cell = [<span class="keyword">self</span> cellWithNib:nib tableView:tableView indexPath:indexPath object:object];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If this assertion fires then your app is about to crash. You need to either add an explicit</span></span><br><span class="line">  <span class="comment">// binding in a NICellFactory object or implement the NICellObject protocol on this object and</span></span><br><span class="line">  <span class="comment">// return a cell class.</span></span><br><span class="line">  NIDASSERT(<span class="literal">nil</span> != cell);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">UITableViewCell</span> *)cellWithClass:(Class)cellClass</span><br><span class="line">                     tableView:(<span class="built_in">UITableView</span> *)tableView</span><br><span class="line">                        object:(<span class="keyword">id</span>)object &#123;</span><br><span class="line">  <span class="built_in">UITableViewCell</span>* cell = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">NSString</span>* identifier = <span class="built_in">NSStringFromClass</span>(cellClass);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ([cellClass respondsToSelector:<span class="keyword">@selector</span>(shouldAppendObjectClassToReuseIdentifier)]</span><br><span class="line">      &amp;&amp; [cellClass shouldAppendObjectClassToReuseIdentifier]) &#123;</span><br><span class="line">    identifier = [identifier stringByAppendingFormat:<span class="string">@&quot;.%@&quot;</span>, <span class="built_in">NSStringFromClass</span>([object <span class="keyword">class</span>])];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cell = [tableView dequeueReusableCellWithIdentifier:identifier];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nil</span> == cell) &#123;</span><br><span class="line">    <span class="built_in">UITableViewCellStyle</span> style = <span class="built_in">UITableViewCellStyleDefault</span>;</span><br><span class="line">    <span class="keyword">if</span> ([object respondsToSelector:<span class="keyword">@selector</span>(cellStyle)]) &#123;</span><br><span class="line">      style = [object cellStyle];</span><br><span class="line">    &#125;</span><br><span class="line">    cell = [[cellClass alloc] initWithStyle:style reuseIdentifier:identifier];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allow the cell to configure itself with the object&#x27;s information.</span></span><br><span class="line">  <span class="comment">// 调用cell类的shouldAppendObjectClassToReuseIdentifier函数，给自定义的cell一个改变自己的机会</span></span><br><span class="line">  <span class="keyword">if</span> ([cell respondsToSelector:<span class="keyword">@selector</span>(shouldUpdateCellWithObject:)]) &#123;</span><br><span class="line">    [(<span class="keyword">id</span>&lt;NICell&gt;)cell shouldUpdateCellWithObject:object];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Cell一气呵成</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义的cell</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TestCell</span> : <span class="title">UITableViewCell</span> &lt;<span class="title">NICell</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TestCell</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">UILabel</span>* lbl;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TestCell</span></span></span><br><span class="line">- (<span class="built_in">BOOL</span>)shouldUpdateCellWithObject:(<span class="keyword">id</span>)object</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_lbl) &#123;</span><br><span class="line">        <span class="built_in">UILabel</span>* tmp = [[<span class="built_in">UILabel</span> alloc] initWithFrame:<span class="keyword">self</span>.bounds];</span><br><span class="line">        <span class="keyword">self</span>.lbl = tmp;</span><br><span class="line">        [<span class="keyword">self</span>.contentView addSubview:_lbl];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSDictionary</span>* data = ((NICellObject*)object).userInfo;</span><br><span class="line">    _lbl.text = data[<span class="string">@&quot;title&quot;</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一气呵成生成cell的相关代码</span></span><br><span class="line"><span class="built_in">UITableView</span>* tmpView = [[<span class="built_in">UITableView</span> alloc] initWithFrame:<span class="keyword">self</span>.view.bounds style:<span class="built_in">UITableViewStyleGrouped</span>];</span><br><span class="line"><span class="keyword">self</span>.testView = tmpView;</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:_testView];</span><br><span class="line"><span class="built_in">NSArray</span>* contentAry = @[ [NICellObject objectWithCellClass:[TestCell <span class="keyword">class</span>] userInfo:@&#123; <span class="string">@&quot;title&quot;</span> : <span class="string">@&quot;hello&quot;</span> &#125;],</span><br><span class="line">                         [NICellObject objectWithCellClass:[TestCell <span class="keyword">class</span>] userInfo:@&#123; <span class="string">@&quot;title&quot;</span> : <span class="string">@&quot;nimbus&quot;</span> &#125;],</span><br><span class="line">                         [NICellObject objectWithCellClass:[TestCell <span class="keyword">class</span>] userInfo:@&#123; <span class="string">@&quot;title&quot;</span> : <span class="string">@&quot;what&quot;</span> &#125;],</span><br><span class="line">                         [NICellObject objectWithCellClass:[TestCell <span class="keyword">class</span>] userInfo:@&#123; <span class="string">@&quot;title&quot;</span> : <span class="string">@&quot;are&quot;</span> &#125;] ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.model = [[NITableViewModel alloc] initWithSectionedArray:contentAry</span><br><span class="line">                                                     delegate:(<span class="keyword">id</span>)[NICellFactory <span class="keyword">class</span>]];</span><br><span class="line"><span class="keyword">self</span>.testView.dataSource = _model;</span><br></pre></td></tr></table></figure>

<h3 id="四、tableview事件处理"><a href="#四、tableview事件处理" class="headerlink" title="四、tableview事件处理"></a>四、tableview事件处理</h3><p>说完了数据源展示，我们在来探索一下table事件处理。Nimbus用到了NITableViewActions类，该类接口定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NITableViewActions</span> : <span class="title">NIActions</span> &lt;<span class="title">UITableViewDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark Forwarding</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>&lt;<span class="built_in">UITableViewDelegate</span>&gt;)forwardingTo:(<span class="keyword">id</span>&lt;<span class="built_in">UITableViewDelegate</span>&gt;)forwardDelegate;</span><br><span class="line">- (<span class="keyword">void</span>)removeForwarding:(<span class="keyword">id</span>&lt;<span class="built_in">UITableViewDelegate</span>&gt;)forwardDelegate;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark Object state</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UITableViewCellAccessoryType</span>)accessoryTypeForObject:(<span class="keyword">id</span>)object;</span><br><span class="line">- (<span class="built_in">UITableViewCellSelectionStyle</span>)selectionStyleForObject:(<span class="keyword">id</span>)object;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark Configurable Properties</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">UITableViewCellSelectionStyle</span> tableViewCellSelectionStyle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>可以看出该类实现了UITableViewDelegate protocol，因此可以当作tableview的事件处理类。NITableViewActions继承自NIActions类，该类又定义如下</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NIActions</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Designated initializer.</span></span><br><span class="line">- (<span class="keyword">id</span>)initWithTarget:(<span class="keyword">id</span>)target;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark Mapping Objects</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)attachToObject:(<span class="keyword">id</span>&lt;<span class="built_in">NSObject</span>&gt;)object tapBlock:(NIActionBlock)action;</span><br><span class="line">- (<span class="keyword">id</span>)attachToObject:(<span class="keyword">id</span>&lt;<span class="built_in">NSObject</span>&gt;)object detailBlock:(NIActionBlock)action;</span><br><span class="line">- (<span class="keyword">id</span>)attachToObject:(<span class="keyword">id</span>&lt;<span class="built_in">NSObject</span>&gt;)object navigationBlock:(NIActionBlock)action;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)attachToObject:(<span class="keyword">id</span>&lt;<span class="built_in">NSObject</span>&gt;)object tapSelector:(SEL)selector;</span><br><span class="line">- (<span class="keyword">id</span>)attachToObject:(<span class="keyword">id</span>&lt;<span class="built_in">NSObject</span>&gt;)object detailSelector:(SEL)selector;</span><br><span class="line">- (<span class="keyword">id</span>)attachToObject:(<span class="keyword">id</span>&lt;<span class="built_in">NSObject</span>&gt;)object navigationSelector:(SEL)selector;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark Mapping Classes</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)attachToClass:(Class)aClass tapBlock:(NIActionBlock)action;</span><br><span class="line">- (<span class="keyword">void</span>)attachToClass:(Class)aClass detailBlock:(NIActionBlock)action;</span><br><span class="line">- (<span class="keyword">void</span>)attachToClass:(Class)aClass navigationBlock:(NIActionBlock)action;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)attachToClass:(Class)aClass tapSelector:(SEL)selector;</span><br><span class="line">- (<span class="keyword">void</span>)attachToClass:(Class)aClass detailSelector:(SEL)selector;</span><br><span class="line">- (<span class="keyword">void</span>)attachToClass:(Class)aClass navigationSelector:(SEL)selector;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark Object State</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isObjectActionable:(<span class="keyword">id</span>&lt;<span class="built_in">NSObject</span>&gt;)object;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>)objectFromKeyClass:(Class)keyClass map:(<span class="built_in">NSMutableDictionary</span> *)map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>从类接口可以直观的看出，该类是把block块或者selector绑定到一个对象上。应该是在内部实际维护了从对象到block块或者selector的关系。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NIActions</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span>* objectToAction;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span>* classToAction;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableSet</span>* objectSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>再从这个类的extention，果断看出了端倪，证明我们的猜测不错。<br>我们来看一个attach方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)attachToObject:(<span class="keyword">id</span>&lt;<span class="built_in">NSObject</span>&gt;)object tapBlock:(NIActionBlock)action &#123;</span><br><span class="line">  [<span class="keyword">self</span>.objectSet addObject:object];</span><br><span class="line">  <span class="comment">//获取该object对应的action数据结构，并且设置该数据结构对应项的值</span></span><br><span class="line">  [<span class="keyword">self</span> actionForObject:object].tapAction = action;</span><br><span class="line">  <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NIObjectActions *)actionForObject:(<span class="keyword">id</span>&lt;<span class="built_in">NSObject</span>&gt;)object &#123;</span><br><span class="line">  <span class="comment">//获取object的hash key</span></span><br><span class="line">  <span class="keyword">id</span> key = [<span class="keyword">self</span> keyForObject:object];</span><br><span class="line">  <span class="comment">//通过object hash key在内部dic中查询NIObjectActions对象，如果没有找到，则新建一个</span></span><br><span class="line">  NIObjectActions* action = [<span class="keyword">self</span>.objectToAction objectForKey:key];</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nil</span> == action) &#123;</span><br><span class="line">    action = [[NIObjectActions alloc] init];</span><br><span class="line">    [<span class="keyword">self</span>.objectToAction setObject:action forKey:key];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> action;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NIObjectActions</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) NIActionBlock tapAction;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) NIActionBlock detailAction;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) NIActionBlock navigateAction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) SEL tapSelector;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) SEL detailSelector;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) SEL navigateSelector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>通过以上函数可以看出NIActions内部用到了NIObjectActions这个数据结构来表示各种action，而NIActions维护了一个从object的hash key到NIObjectActions对象的关系。<br>我再回过头来看NITableViewActions类的UITableViewDelegate实现，具体函数如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView didSelectRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">  NIDASSERT([tableView.dataSource isKindOfClass:[NITableViewModel <span class="keyword">class</span>]]);</span><br><span class="line">  <span class="keyword">if</span> ([tableView.dataSource isKindOfClass:[NITableViewModel <span class="keyword">class</span>]]) &#123;</span><br><span class="line">    NITableViewModel* model = (NITableViewModel *)tableView.dataSource;</span><br><span class="line">    <span class="comment">//从model中获取cell内容对象</span></span><br><span class="line">    <span class="keyword">id</span> object = [model objectAtIndexPath:indexPath];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isObjectActionable:object]) &#123;</span><br><span class="line">      <span class="comment">//查询cell内容对象的action对象（NIObjectActions）</span></span><br><span class="line">      NIObjectActions* action = [<span class="keyword">self</span> actionForObjectOrClassOfObject:object];</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果action对象中设置了tapAction block ，调用之</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">BOOL</span> shouldDeselect = <span class="literal">NO</span>;</span><br><span class="line">      <span class="keyword">if</span> (action.tapAction) &#123;</span><br><span class="line">        <span class="comment">// Tap actions can deselect the row if they return YES.</span></span><br><span class="line">        shouldDeselect = action.tapAction(object, <span class="keyword">self</span>.target, indexPath);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果action对象中设置了tapSelector，并且目标对象（由NITableViewActions对象保存）能响应tapSelector，调用之</span></span><br><span class="line">      <span class="keyword">if</span> (action.tapSelector &amp;&amp; [<span class="keyword">self</span>.target respondsToSelector:action.tapSelector]) &#123;</span><br><span class="line">        <span class="comment">//多参数不能直接performSelector</span></span><br><span class="line">        <span class="built_in">NSMethodSignature</span> *methodSignature = [<span class="keyword">self</span>.target methodSignatureForSelector:action.tapSelector];</span><br><span class="line">        <span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:methodSignature];</span><br><span class="line">        invocation.selector = action.tapSelector;</span><br><span class="line">        <span class="keyword">if</span> (methodSignature.numberOfArguments &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">          [invocation setArgument:&amp;object atIndex:<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (methodSignature.numberOfArguments &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">          [invocation setArgument:&amp;indexPath atIndex:<span class="number">3</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        [invocation invokeWithTarget:<span class="keyword">self</span>.target];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSUInteger</span> length = invocation.methodSignature.methodReturnLength;</span><br><span class="line">        <span class="keyword">if</span> (length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">char</span> *buffer = (<span class="keyword">void</span> *)malloc(length);</span><br><span class="line">          memset(buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * length);</span><br><span class="line">          [invocation getReturnValue:buffer];</span><br><span class="line">          <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> index = <span class="number">0</span>; index &lt; length; ++index) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buffer[index]) &#123;</span><br><span class="line">              shouldDeselect = <span class="literal">YES</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          free(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (shouldDeselect) &#123;</span><br><span class="line">        [tableView deselectRowAtIndexPath:indexPath animated:<span class="literal">YES</span>];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (action.navigateAction) &#123;</span><br><span class="line">        action.navigateAction(object, <span class="keyword">self</span>.target, indexPath);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//直接performSelector</span></span><br><span class="line">      <span class="keyword">if</span> (action.navigateSelector &amp;&amp; [<span class="keyword">self</span>.target respondsToSelector:action.navigateSelector]) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Warc-performSelector-leaks&quot;</span></span></span><br><span class="line">        [<span class="keyword">self</span>.target performSelector:action.navigateSelector withObject:object withObject:indexPath];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Forward the invocation along.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">id</span>&lt;<span class="built_in">UITableViewDelegate</span>&gt; delegate <span class="keyword">in</span> <span class="keyword">self</span>.forwardDelegates) &#123;</span><br><span class="line">    <span class="keyword">if</span> ([delegate respondsToSelector:_cmd]) &#123;</span><br><span class="line">      [delegate tableView:tableView didSelectRowAtIndexPath:indexPath];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以一个table的action可能是这样的</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.actions = [[NITableViewActions alloc] initWithTarget:<span class="keyword">self</span>];</span><br><span class="line"><span class="keyword">self</span>.testView.delegate = _actions;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSArray</span>* contentAry = @[</span><br><span class="line">    [_actions attachToObject:[NICellObject objectWithCellClass:[TestCell <span class="keyword">class</span>] userInfo:@&#123; <span class="string">@&quot;title&quot;</span> : <span class="string">@&quot;hello&quot;</span> &#125;]</span><br><span class="line">                    tapBlock:^<span class="built_in">BOOL</span>(<span class="keyword">id</span> object, <span class="keyword">id</span> target, <span class="built_in">NSIndexPath</span>* indexPath) &#123;</span><br><span class="line">                        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, indexPath);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">                    &#125;],</span><br><span class="line">    [NICellObject objectWithCellClass:[TestCell <span class="keyword">class</span>] userInfo:@&#123; <span class="string">@&quot;title&quot;</span> : <span class="string">@&quot;nimbus&quot;</span> &#125;],</span><br><span class="line">    [NICellObject objectWithCellClass:[TestCell <span class="keyword">class</span>] userInfo:@&#123; <span class="string">@&quot;title&quot;</span> : <span class="string">@&quot;what&quot;</span> &#125;],</span><br><span class="line">    [NICellObject objectWithCellClass:[TestCell <span class="keyword">class</span>] userInfo:@&#123; <span class="string">@&quot;title&quot;</span> : <span class="string">@&quot;are&quot;</span> &#125;]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.model = [[NITableViewModel alloc] initWithSectionedArray:contentAry</span><br><span class="line">                                                     delegate:(<span class="keyword">id</span>)[NICellFactory <span class="keyword">class</span>]];</span><br><span class="line"><span class="keyword">self</span>.testView.dataSource = _model;</span><br></pre></td></tr></table></figure>

<p>model里面表示cell内容的对象可以被attach到actions对象上。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/05/19/2014-05-19-Chromium%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B(CSDN%E6%97%A9%E6%9C%9F%E5%8D%9A%E5%AE%A2)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/img/common/avatar.jpg">
      <meta itemprop="name" content="宿于松下">
      <meta itemprop="description" content="行有不得反求诸己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="宿于松下的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2014/05/19/2014-05-19-Chromium%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B(CSDN%E6%97%A9%E6%9C%9F%E5%8D%9A%E5%AE%A2)/" class="post-title-link" itemprop="url">Chromium的启动流程(CSDN早期博客)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2014-05-19 00:00:00" itemprop="dateCreated datePublished" datetime="2014-05-19T00:00:00+08:00">2014-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-15 17:11:41" itemprop="dateModified" datetime="2021-08-15T17:11:41+08:00">2021-08-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1引言"><a href="#1引言" class="headerlink" title="1引言"></a>1引言</h3><p>你点击了桌面上的Chrome图标，一个浏览器窗口出现了，输入网址就可以在Internet世界愉快玩耍。这一切是怎么实现的呢？Chromium这个多进程的程序是如何启动各个进程的呢？浏览器主进程（界面进程）启动了哪些线程？如何启动的呢？这些问题一直萦绕在心头，一起来看看源代码吧。本文主要针对Chromium for Mac的源代码，其它操作系统大同小异。</p>
<h3 id="2背景知识"><a href="#2背景知识" class="headerlink" title="2背景知识"></a>2背景知识</h3><p>浏览器作为一个应用程序，是以进程的形式运行在操作系统上的。首先，Chromium是一个多进程的应用程序，我们需要了解Chromium的多进程框架。其次，Chromium中的每个进程又是多线程的，因而又需要了解Chromium的线程设计。接下来我们就从进程和线程入手介绍相关背景知识。</p>
<h4 id="2-1多进程框架"><a href="#2-1多进程框架" class="headerlink" title="2.1多进程框架"></a>2.1多进程框架</h4><p>Chromium是个多进程程序，每当你点开Chromium图标，默认会启动多个进程。Google之所以这样设计，是怕你打开某个挫B网站而把它的整个浏览器全部弄崩掉。所以它利用现代操作系统多进程不同地址空间这个设计，把它整个浏览器分为多进程，这样即使一个进程崩掉了，也不一定会让整个浏览器崩掉。Chromium进程分为一般分为两类：第一类，Browser进程，它管理tabs和插件进程以及运行主界面UI。第二类，Renderer进程，它利用WebKit布局引擎来解释和布局HTML。Browser是老大，只有一个；Renderer是小弟可以有很多个，每个小弟都能跟老大相互通信，但是小弟之间不能相互通信。老大和小弟们之间的关系如下。</p>
<p><img src="/assets/img/postImage/Chromium%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B-CSDN%E6%97%A9%E6%9C%9F%E5%8D%9A%E5%AE%A2/1.png" alt="1"></p>
<p> 从上图可以看出每个Renderer进程都有一个RenderProcess对象，这个对象是用来管理整个Renderer进程的；与之对应的，Browser进程有许多RenderProcessHost对象，每个对象对应一个RenderProcess对象，也即是对应一个Renderer进程。</p>
<h4 id="2-2多线程框架"><a href="#2-2多线程框架" class="headerlink" title="2.2多线程框架"></a>2.2多线程框架</h4><p>我们平时写程序也用多线程，其中一个常见的场景是把UI和费时处理过程分离，让他们拥有各自的线程。Chromium中的多线程基本是同理的，为了保证UI的快速响应，防止IO阻塞和费时计算而利用了多线程。但是我们在处理多线程共享资源的时候通常是利用锁，这容易引发各种莫名奇妙的问题，如死锁、优先级反转等。Chromium为了避免这些问题就少用锁，它有一些简单的约定：</p>
<ol>
<li>线程之间通过传递消息来交流(确切来说是传递任务)；</li>
<li>对象只存在在一个线程上。</li>
</ol>
<p>BrowserProcess类是Browser进程的服务管理者，它控制着大多数的线程。通常程序运行在UI线程，但是我们把某些类型的处理放到其他线程。这些线程如下：</p>
<p> ui_thread：应用程序启动时的主线程。</p>
<p> io_thread：这个线程的名字有点令人费解。它是处理browser进程和所有子进程之间通信的调度线程。它也负责所有的资源请求（网页加载）的分发（见多进程架构）。</p>
<p>file_thread：文件操作的通用线程。当你想执行阻塞文件系统的操作（例如，请求某种文件一个图标，把下载文件写到磁盘），会调用该线程。</p>
<p> db_thread：数据库操作的线程。例如，Cookie服务在这个线程上使用SQLite操作。注意，历史数据库不使用该线程。</p>
<p>本文也主要是讨论Browser上的线程何时启动的。更多关于Chromium进程和线程框架请参考：<br><a target="_blank" rel="noopener" href="http://www.chromium.org/developers/design-documents/multi-process-architecture">http://www.chromium.org/developers/design-documents/multi-process-architecture</a></p>
<p><a target="_blank" rel="noopener" href="http://www.chromium.org/developers/design-documents/threading">http://www.chromium.org/developers/design-documents/threading</a></p>
<h3 id="3Browser多线程的创建和启动"><a href="#3Browser多线程的创建和启动" class="headerlink" title="3Browser多线程的创建和启动"></a>3Browser多线程的创建和启动</h3><p> 双击浏览器图标，我们启动了一个Chromium进程，这就是Browser进程。用C++编写的程序启动函数是main，Chromium当然也不例外。具体流程如下图所示:</p>
<p><img src="/assets/img/postImage/Chromium%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B-CSDN%E6%97%A9%E6%9C%9F%E5%8D%9A%E5%AE%A2/2.png" alt="2"></p>
<p>其中,RunNamedProcessTypeMain是个很重要的函数<br>该函数定义于”content/public/app/content_main_runner.cc”文件。</p>
<p>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RunNamedProcessTypeMain</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; process_type,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> MainFunctionParams&amp; main_function_params,</span></span></span><br><span class="line"><span class="function"><span class="params">    ContentMainDelegate* delegate)</span></span></span><br></pre></td></tr></table></figure>

<p>该函数内部定义了个静态结构体数组：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> MainFunction kMainFunctions[] = &#123;</span><br><span class="line">#<span class="keyword">if</span> !defined(CHROME_MULTIPLE_DLL_CHILD)</span><br><span class="line">    &#123; <span class="string">&quot;&quot;</span>,                            BrowserMain &#125;,</span><br><span class="line">#endif</span><br><span class="line">#<span class="keyword">if</span> !defined(CHROME_MULTIPLE_DLL_BROWSER)</span><br><span class="line">#<span class="keyword">if</span> defined(ENABLE_PLUGINS)</span><br><span class="line">    &#123; switches::kPluginProcess,      PluginMain &#125;,</span><br><span class="line">    &#123; switches::kWorkerProcess,      WorkerMain &#125;,</span><br><span class="line">    &#123; switches::kPpapiPluginProcess, PpapiPluginMain &#125;,</span><br><span class="line">    &#123; switches::kPpapiBrokerProcess, PpapiBrokerMain &#125;,</span><br><span class="line">#endif  <span class="comment">// ENABLE_PLUGINS</span></span><br><span class="line">    &#123; switches::kUtilityProcess,     UtilityMain &#125;,</span><br><span class="line">    &#123; switches::kRendererProcess,    RendererMain &#125;,</span><br><span class="line">    &#123; switches::kGpuProcess,         GpuMain &#125;,</span><br><span class="line">#endif  <span class="comment">// !CHROME_MULTIPLE_DLL_BROWSER</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>该结构体有两个成员，一个是<code>const char process_type[]</code>表示进程类型，它从启动进程传入的参数解析得到；另一个是函数指针，表示该进程对应的主函数。对于Browser进程而言，它的启动参数是空的，解析出来<code>process_type</code>也是空的。我们从上面的结构体数组可以看到，空参数表示该进程的主函数是<code>BrowserMain</code>。我们再来看看<code>BrowserMain</code>中做了啥。主要代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">scoped_ptr&lt;BrowserMainRunner&gt; <span class="title">main_runner</span><span class="params">(BrowserMainRunner::Create())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> exit_code = main_runner-&gt;Initialize(parameters);</span><br><span class="line"><span class="keyword">if</span> (exit_code &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> exit_code;</span><br><span class="line"></span><br><span class="line">exit_code = main_runner-&gt;Run();</span><br></pre></td></tr></table></figure>

<p>我们可以看出该函数主要是创建了一个BrowserMainRunner对象，然后Initialize，紧接着Run。BrowserMainRunner的相关类图如下所示。</p>
<p><img src="/assets/img/postImage/Chromium%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B-CSDN%E6%97%A9%E6%9C%9F%E5%8D%9A%E5%AE%A2/3.png" alt="3"></p>
<p>从类图可以看出BrowserMainRunner是个接口类，该类包含3个接口方法：Initialize、Run、Shutdown。其实现类是BrowserMainRunnerImpl。该类管理了一个BrowserMainLoop对象，通过控制BrowserMainLoop来控制该进程。我们可以发现BrowserMainLoop对象管理了许多线程对象，如：<code>main­­_thread</code>、<code>db_thread</code> 、<code>file_thread</code>等。这就是Browser进程中的主要线程对象。相关序列图如下图所示。</p>
<p><img src="/assets/img/postImage/Chromium%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B-CSDN%E6%97%A9%E6%9C%9F%E5%8D%9A%E5%AE%A2/4.bmp" alt="4"></p>
<p>main_runner在Initialize的时候创造了BrowserMainLoop对象，并调用了该对象的Initialize函数和CreateStartupTasks函数。而CreateStartupTask调用的时候创建了一个StartupTaskRunner对象，利用该对象来管理Startup Tasks，比如添加任务、执行任务。在此函数中就利用了AddTask来添加任务，其中一个重要的任务是CreateThreads，即把所有他管理的线程对象创建起来。该函数具体如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BrowserMainLoop::CreateStartupTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//other code</span></span><br><span class="line">    StartupTask pre_create_threads =</span><br><span class="line">        base::Bind(&amp;BrowserMainLoop::PreCreateThreads, base::Unretained(<span class="keyword">this</span>));</span><br><span class="line">    startup_task_runner_-&gt;AddTask(pre_create_threads);</span><br><span class="line"></span><br><span class="line">    StartupTask create_threads =</span><br><span class="line">        base::Bind(&amp;BrowserMainLoop::CreateThreads, base::Unretained(<span class="keyword">this</span>));</span><br><span class="line">    startup_task_runner_-&gt;AddTask(create_threads);</span><br><span class="line"></span><br><span class="line">    StartupTask browser_thread_started = base::Bind(</span><br><span class="line">        &amp;BrowserMainLoop::BrowserThreadsStarted, base::Unretained(<span class="keyword">this</span>));</span><br><span class="line">    startup_task_runner_-&gt;AddTask(browser_thread_started);</span><br><span class="line"></span><br><span class="line">    StartupTask pre_main_message_loop_run = base::Bind(</span><br><span class="line">        &amp;BrowserMainLoop::PreMainMessageLoopRun, base::Unretained(<span class="keyword">this</span>));</span><br><span class="line">    startup_task_runner_-&gt;AddTask(pre_main_message_loop_run);</span><br><span class="line"></span><br><span class="line">    startup_task_runner_-&gt;RunAllTasksNow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是Browser各种主要线程创建的时机。</p>
<h3 id="4多进程的创建和启动"><a href="#4多进程的创建和启动" class="headerlink" title="4多进程的创建和启动"></a>4多进程的创建和启动</h3><p>上文我们已经提到，Chromium是一种多进程的程序，那除了双击启动的Browser进程，其它的小弟进程Renderer在哪里启动的呢？通过上文，我们知道每个Renderer都有个RenderProcess对象，相应的Browser上有于之对应的RenderProcessHost对象。追踪源码我们可以发现，在RenderProcessHostImpl类的Init函数中，有这样几行代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">child_process_launcher_.reset(<span class="keyword">new</span> ChildProcessLauncher(</span><br><span class="line">#<span class="keyword">if</span> defined(OS_WIN)</span><br><span class="line">        <span class="keyword">new</span> RendererSandboxedProcessLauncherDelegate,</span><br><span class="line">#elif defined(OS_POSIX)</span><br><span class="line">        renderer_prefix.empty(),</span><br><span class="line">        base::EnvironmentMap(),</span><br><span class="line">        channel_-&gt;TakeClientFileDescriptor(),</span><br><span class="line">#endif</span><br><span class="line">        cmd_line,</span><br><span class="line">        GetID(),</span><br><span class="line">        <span class="keyword">this</span>));</span><br></pre></td></tr></table></figure>

<p>该函数new了一个ChildProcessLauncher对象，再看看对应的构造函数，里面有如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">context_ = <span class="keyword">new</span> Context();</span><br><span class="line">  context_-&gt;Launch(</span><br><span class="line">#<span class="keyword">if</span> defined(OS_WIN)</span><br><span class="line">      delegate,</span><br><span class="line">#elif defined(OS_ANDROID)</span><br><span class="line">      ipcfd,</span><br><span class="line">#elif defined(OS_POSIX)</span><br><span class="line">      use_zygote,</span><br><span class="line">      environ,</span><br><span class="line">      ipcfd,</span><br><span class="line">#endif</span><br><span class="line">      cmd_line,</span><br><span class="line">      child_process_id,</span><br><span class="line">      client);</span><br></pre></td></tr></table></figure>

<p>Launch函数的内部又做了什么呢？代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BrowserThread::PostTask(</span><br><span class="line">    BrowserThread::PROCESS_LAUNCHER, FROM_HERE,</span><br><span class="line">    base::Bind(</span><br><span class="line">        &amp;Context::LaunchInternal,</span><br><span class="line">        make_scoped_refptr(<span class="keyword">this</span>),</span><br><span class="line">        client_thread_id_,</span><br><span class="line">        child_process_id,</span><br><span class="line">        use_zygote,</span><br><span class="line">        environ,</span><br><span class="line">        ipcfd,</span><br><span class="line">        cmd_line));</span><br></pre></td></tr></table></figure>

<p>可以看出它PostTask到BrowserThread::PROCESS_LAUNCHER，让其执行Context ::LaunchInternal任务。再来看看这个函数，里面有一行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> launched = base::LaunchProcess(*cmd_line, options, &amp;handle);</span><br></pre></td></tr></table></figure>

<p>这个函数调用fork()然后execvp ()启动了子进程。子进程会执行上文的RunNamedProcessTypeMain函数，但是这次它是带执行参数的，所以不会进入BrowserMain函数，而是进入其它函数，如：RendererMain等。以上就是子进程的启动流程了。</p>
<h3 id="5总结"><a href="#5总结" class="headerlink" title="5总结"></a>5总结</h3><p>Browser多线程启动</p>
<ol>
<li>Browser主函数是BrowserMain，该函数创建了一个BrowserMainRunnerImpl对象，同时执行了该对象的Initialize函数；</li>
<li>BrowserMainRunnerImpl的Initialize创建了一个BrowserMainLoop对象，同时执行了该对象的Init和CreateStartupTasks函数；</li>
<li>BrowserMainLoop的CreateStartupTasks添加了一堆任务，其中一个任务就是CreateThreads函数；</li>
<li>在CreateThreads函数中会初始化各种线程对象，并且StartWithOptions。</li>
</ol>
<p>Chromium多进程</p>
<ol>
<li>双击Chromium图标启动第一个进程，即Browser进程；</li>
<li>Browser进程中RenderProcessHostImpl对象的Init函数会new一个ChildProcessLauncher对象，该对象来管理子进程的启动；</li>
<li>ChildProcessLauncher构造过程中会借助其Context对象，Post一个Task到PROCESS_LAUNCHER线程；</li>
<li>Task会执行base::LaunchProcess,该函数调用fork()然后execvp ()启动了子进程；</li>
<li>启动的子进程是带参数的，这次在执行RunNamedProcessTypeMain的时候不会进入BrowserMain，而是进入其对应的主函数。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/01/06/2014-01-06-%20%E4%BB%8EC++%E5%88%B0Objective-C%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(CSDN%E6%97%A9%E6%9C%9F%E5%8D%9A%E5%AE%A2)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/img/common/avatar.jpg">
      <meta itemprop="name" content="宿于松下">
      <meta itemprop="description" content="行有不得反求诸己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="宿于松下的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2014/01/06/2014-01-06-%20%E4%BB%8EC++%E5%88%B0Objective-C%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(CSDN%E6%97%A9%E6%9C%9F%E5%8D%9A%E5%AE%A2)/" class="post-title-link" itemprop="url">从C++到Objective-C的学习笔记(CSDN早期博客)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2014-01-06 00:00:00" itemprop="dateCreated datePublished" datetime="2014-01-06T00:00:00+08:00">2014-01-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-15 17:11:41" itemprop="dateModified" datetime="2021-08-15T17:11:41+08:00">2021-08-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1头文件导入与新的基本类型"><a href="#1头文件导入与新的基本类型" class="headerlink" title="1头文件导入与新的基本类型"></a>1头文件导入与新的基本类型</h3><p>OC的头文件跟C和CPP一样都是.h，而OC的源文件是.m</p>
<p>导入头文件是用<code>#import</code>，这比<code>#include</code>好的地方在于默认设置了头文件保护，不需要在头文件中设置保护符</p>
<p><code>#import &lt;Foundation/Foundation.h&gt;</code></p>
<p>前面的Foundation是框架名，后面的Foundation.h是头文件名</p>
<p>OC引入了新的基本类型BOOL，类似于CPP中的bool，但是BOOL的值是YES /NO</p>
<table>
<thead>
<tr>
<th>语言</th>
<th>C</th>
<th>CPP</th>
<th>ObjC</th>
</tr>
</thead>
<tbody><tr>
<td><strong>源文件</strong></td>
<td>.c</td>
<td>.cpp</td>
<td>.m</td>
</tr>
<tr>
<td><strong>.h导入符号</strong></td>
<td><code>#include</code></td>
<td><code>#include</code></td>
<td><code>#import</code></td>
</tr>
<tr>
<td><strong>.h导入方式</strong></td>
<td>导入文件名</td>
<td>导入文件名</td>
<td>导入框架/文件名</td>
</tr>
<tr>
<td><strong>Log输出</strong></td>
<td>printf</td>
<td>cout</td>
<td>NSLog</td>
</tr>
</tbody></table>
<h3 id="2面向对象"><a href="#2面向对象" class="headerlink" title="2面向对象"></a>2面向对象</h3><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>创建一个OC类的关键字是@interface，实现一个类的关键词是@implementation</p>
<p>而CPP创建类是class，实现类没有关键词，只是函数前面都要加”类名::”。</p>
<p>所有的OC类必须要直接或者间接继承NSObject类。而CPP没有限制</p>
<p>OC在类的.h文件中不定义方法名字，直接在.m文件中写这些方法是没问题的。</p>
<p>而CPP必须要在头文件的class块中定义方法名字，才能在.CPP中实现。</p>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>OC的对象全部是new出来的，都存在heap上，而CPP的对象可能存在stack上，也可能在heap上</p>
<h4 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h4><p>OC对对象的调用是基于消息的。这样即使在类的中没有明确指出该消息，也能调用该消息。编译是能过的。</p>
<p>CPP类要是没有写出成员函数，调用该成员函数是肯定编译不过的。</p>
<h4 id="类对象与OC对象模型"><a href="#类对象与OC对象模型" class="headerlink" title="类对象与OC对象模型"></a>类对象与OC对象模型</h4><p>OC中存在类对象，每个OC对象中都有一个指针指向其类对象，以此来标识这个对象所从属的类。类对象也是一种对象。OC的面向对象模型是基于这种类对象，查表找对应的函数。</p>
<p>CPP中无类对象，面向对象的多态是基于vtbl</p>
<table>
<thead>
<tr>
<th>对象模型</th>
<th>CPP</th>
<th>ObjC</th>
</tr>
</thead>
<tbody><tr>
<td>文档</td>
<td>《深度探索C++对象模型》</td>
<td>《深入浅出Cocoa教程》</td>
</tr>
<tr>
<td>作者</td>
<td>侯捷</td>
<td>白云飘飘</td>
</tr>
</tbody></table>
<p>OC多了类对象一层，程序多了一层间接性，因此效率比CPP要低一些，但是正因为这种间接性，所用其编程的灵活性应该比CPP要强，更加容易设计出易于扩展和维护的程序。因此OC中的设计模式可能更加灵活。</p>
<h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p>OC中的id类型泛指某个对象的指针，其实可以看作NSObject*<br>对应的CPP中相当于void*</p>
<h4 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h4><p>OC中每个成员函数都可以当作虚函数，而CPP中标记为virtual的成员函数才是虚函数。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>OC只支持单继承，而且没有继承方式<br>CPP支持多继承，继承方式有public、protected、private</p>
<h4 id="Big3"><a href="#Big3" class="headerlink" title="Big3"></a>Big3</h4><p><strong>构造</strong></p>
<p>OC中以init开头的函数是构造函数，但是它不会像CPP的构造函数那样先帮你调用父类的构造函数。在OC中需要手动调用[super init];</p>
<p><strong>析构</strong></p>
<p>OC对象的析构函数统一为-(void) dealloc; 析构本类成员后需要手动调用[super dealloc];</p>
<p><strong>复制构造</strong></p>
<p>OC对象的复制构造以copy 或者 mutableCopy开头</p>
<h3 id="3内存管理"><a href="#3内存管理" class="headerlink" title="3内存管理"></a>3内存管理</h3><p>OC的对象全部是alloc后init的存在heap上，stack上只是保存OC对象的指针。</p>
<p>不同的指针指向同一个heap对象的时候是以引用计数的方式进行统计的。</p>
<p>对象初创的时候，其计数是1， retain消息会把对象引用计数+1，release消息会把对象引用计数-1。当引用计数减到0的时候，自动调用对象的dealloc函数，对对象进行析构。</p>
<p>autorelease消息会把对象注册到距离最近的AutoreleasePool上去，一但这个AutoreleasePool被析构，它会向注册到其上的每个对象发一个release消息，使他们的对象引用计数-1。</p>
<h3 id="4property（属性）"><a href="#4property（属性）" class="headerlink" title="4property（属性）"></a>4property（属性）</h3><p>在类声明的时候以@property的方式来声明一个属性，</p>
<p>在类实现的时候以@synthesize来实现属性的存取方法</p>
<p>MRC模式下属性的参数</p>
<p>1复制<br>assign（默认），retain，copy</p>
<p>2读写<br>readwrite(默认)，readonly</p>
<p>3原子性<br> atomic（默认）nonatomic</p>
<h3 id="5category（类别）"><a href="#5category（类别）" class="headerlink" title="5category（类别）"></a>5category（类别）</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> 宿主类名（类别名）</span></span><br><span class="line">声明方式如下：</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HostClass</span>(<span class="title">MyCategory</span>)</span></span><br><span class="line">-(<span class="keyword">void</span>) categoryFunc;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>作用：</p>
<ol>
<li>分散类的实现，一个大类分拆成小的category</li>
<li>为类添加前向声明（消除编译器的warning）</li>
<li>当作非正式的协议，category中的方法不必每个都实现</li>
</ol>
<h3 id="6protocol（协议）"><a href="#6protocol（协议）" class="headerlink" title="6protocol（协议）"></a>6protocol（协议）</h3><p>用@protocol来声明协议，若某个类需要实现协议必须把协议放在他父类的尖括号列表中，并且该类必须实现protocol中的所有声明的方法<br>如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//protocol definition</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">Myprotocol</span></span></span><br><span class="line">-(<span class="keyword">void</span>) protocolFun;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="comment">//use protocol</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span>&lt;<span class="title">Myprotocol</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h3 id="7delegate（委托）"><a href="#7delegate（委托）" class="headerlink" title="7delegate（委托）"></a>7delegate（委托）</h3><p>委托是一种设计模式，就是把本类需要实现的东西，交给其委托类去实现，一般来说委托是基于protocol的，用protocol是声明某种接口，比如</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">MyDelegate</span></span></span><br><span class="line">-(<span class="keyword">void</span>) delegateFunc;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HostClass</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">NSObject</span>&lt;MyDelegate&gt;  *delegate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>实现MyDelegate协议的所有类都能当作HostClass的委托对象。</p>
<h3 id="8-常用的Foundation-Kit类"><a href="#8-常用的Foundation-Kit类" class="headerlink" title="8 常用的Foundation Kit类"></a>8 常用的Foundation Kit类</h3><p>字符串</p>
<p>NSString：类似于string，但是！!!不能直接用＝＝比较两个字符是否相等，因为OC没有操作符重载,应该使用isEqualToString</p>
<p>集合</p>
<p>NSArray\NSMutableArray：类似于vector<br>NSDictionary\NSMutableDictionary： 类似于map！！！objectForKey和KVC的valueForKey；setObject：forKey：和KVC的setValue：forKey：不要混淆</p>
<p>数值</p>
<p>NSNumber：标量的类封装，如int，float等都可以使用NSNumber封装<br>NSValue：任意类型的类封装，以byte方式实现<br>NSNull：nil的类封装</p>
<h3 id="9KVC"><a href="#9KVC" class="headerlink" title="9KVC"></a>9KVC</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">来设置对象中的属性</span><br><span class="line">- (<span class="keyword">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">来获取对象中的属性</span><br><span class="line">内部调用的是key名称的property，如果没有property，就就直接查找key名称或者_key名称的成员变量</span><br><span class="line">路径</span><br><span class="line">- (<span class="keyword">id</span>) valueForKeyPath:(<span class="built_in">NSString</span> *)key</span><br><span class="line">获取路径上的属性值</span><br><span class="line">整体操作</span><br><span class="line">如果向<span class="built_in">NSArray</span>请求一个键值，它实际上会查询数组中的每个对象来查找这个值，然后讲查询结果打包到另外一个数组并且返回给你</span><br><span class="line">运算符</span><br><span class="line">用- (<span class="keyword">id</span>) valueForKeyPath:(<span class="built_in">NSString</span> *)key可以引用一些运算符来进行运算</span><br><span class="line">@count计算左侧的结果,用于计数</span><br><span class="line">@sum计算总和,如:<span class="string">@&quot;cars.@sum.mileage&quot;</span> @sum将结果拆成两部分</span><br><span class="line">@agv计算平均值,如:<span class="string">@&quot;cars.@avg.mileage&quot;</span></span><br><span class="line">@min取最小值</span><br><span class="line">@max取最大值</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2013/03/13/2013-03-13-%E5%AE%9E%E4%B9%A0%E7%94%9F%E9%9D%A2%E8%AF%95(CSDN%E6%97%A9%E6%9C%9F%E5%8D%9A%E5%AE%A2)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/img/common/avatar.jpg">
      <meta itemprop="name" content="宿于松下">
      <meta itemprop="description" content="行有不得反求诸己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="宿于松下的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2013/03/13/2013-03-13-%E5%AE%9E%E4%B9%A0%E7%94%9F%E9%9D%A2%E8%AF%95(CSDN%E6%97%A9%E6%9C%9F%E5%8D%9A%E5%AE%A2)/" class="post-title-link" itemprop="url">实习生面试(CSDN早期博客)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2013-03-13 00:00:00" itemprop="dateCreated datePublished" datetime="2013-03-13T00:00:00+08:00">2013-03-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-15 17:11:41" itemprop="dateModified" datetime="2021-08-15T17:11:41+08:00">2021-08-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-百度-数据分析部门"><a href="#1-百度-数据分析部门" class="headerlink" title="1.百度-数据分析部门"></a>1.百度-数据分析部门</h3><p>公司:百度<br>转正:实习生转正率70%~80%，9月份转正<br>2013年3月5日14：00<br>数据分析部门</p>
<p>一面：</p>
<ol>
<li>笔写链表判环算法</li>
<li>10G数求前K个</li>
<li>给出以p概率生成0，1-p概率生成1的函数，设计以等概率生成0和1的函数。进一步设计随机数生成器。</li>
<li>想法，如何搜集用户信息</li>
</ol>
<p>一面通过</p>
<p>二面：</p>
<ol>
<li>一个log文件含有大小10G的query，求前K个出现次数最多的query</li>
<li>给出一个数据库设计，分析不足之处</li>
<li>随便写一个排序算法</li>
<li>代码量多少</li>
<li>想法，如何判断刘德华和郭富城的关系</li>
</ol>
<p>二面挂了</p>
<p><strong>不足之处：笔写函数的熟练度，对常见排序算法的理解，数据库的常见知识点，索引之类。</strong></p>
<h3 id="2-百度-基础平台部"><a href="#2-百度-基础平台部" class="headerlink" title="2.百度-基础平台部"></a>2.百度-基础平台部</h3><p>公司:百度<br>2013年03月11日 14：00<br>基础平台部的C/C++实习研发工程师 </p>
<p>一面：</p>
<p>面试官：研发工程师</p>
<ol>
<li>笔写c++实现一个栈</li>
<li>IPC的几种方式</li>
<li>笔写链表逆序</li>
<li>智力题，100小球在管道对碰问题</li>
</ol>
<p>一面通过</p>
<p>二面：</p>
<p>面试官：资深研发工程师</p>
<ol>
<li>给1000万个北京电话号码排序，给出算法，分析时间复杂度</li>
<li>二叉树遍历时间空间复杂度</li>
<li>KMP算法</li>
<li>c++实现不能被继承的类</li>
<li>auto_ptr如何管理vector，auto_ptr的作用</li>
<li>N个数前M大</li>
<li>iostream和iostream.h的区别</li>
<li>vector排序</li>
<li>进程和线程区别</li>
<li>笔写c++实现string类，实现big3，以及赋值操作符</li>
</ol>
<p>二面通过</p>
<p>三面：</p>
<p>面试官：经理</p>
<p>首先给简历，没有固定题目，随便了解</p>
<ol>
<li>问对网络编程的了解，四层协议，分别解释一下</li>
<li>问数据库范式的作用，分别解释</li>
<li>数据库容量瓶颈在哪里，为什么不能把数据库设为无限大</li>
<li>多线程的项目经历</li>
<li>自身最大优点是什么，怎么证明</li>
<li>为什么在简历中说善于发现bug，如果一个函数10次中有7次正确，3次错误，问题可能出现在哪里。你怎么解决问题，找到bug</li>
<li>所用过的互联网产品，人人和微信各有什么特点</li>
<li>职业规划如何，为什么不去研究所</li>
</ol>
<p>三面挂了</p>
<p><strong>不足之处：STL底层，算法时间复杂度分析，数据库的常见知识点，操作系统进程线程，及其通信同步。</strong></p>
<h3 id="3-SYMTEC"><a href="#3-SYMTEC" class="headerlink" title="3.SYMTEC"></a>3.SYMTEC</h3><p>公司：SYMTEC</p>
<p>转正：完成实习任务即可转正，概率很高</p>
<p>研发环境：linux，unix，shell，perl，jquery</p>
<p>软件：Storge Foundation相关内部工具</p>
<p>户口：每年有名额，由FESCO管理</p>
<p>2013.03.<strong>.</strong>.**<br>电话面试<br>面试官：**技术人员</p>
<ol>
<li>数组逆序</li>
<li>字符拷贝</li>
<li>SQL查找取前100个</li>
<li>英语自我介绍，</li>
<li>英文对话</li>
</ol>
<p>2013.03.15.16.30<br>面试<br>面试官：技术员1，技术员2，hr。三人同时</p>
<p>技术员1：</p>
<ol>
<li>基类析构函数设置为virtual的作用，在实际工程项目中是否遇到过memory leak</li>
<li>C++多继承出现钻石环，孙子类调用祖父类的函数会有什么情况</li>
<li>介绍STL，vector的底层实现，sizeof（vector<int>）是多少，map底层实现</li>
<li>MFC中所有窗口都继承的类，MFC中所有类都是从什么类派生的（注：面试官出的题目有错误，有些类不是从CObject继承的，比如CPoint）</li>
<li>CString和string的相互转化</li>
<li>引用和指针的区别，是否可以有const引用</li>
<li>C语言中的malloc和C++中new的区别</li>
</ol>
<p>技术员2：</p>
<ol>
<li>SQL查找取前100个</li>
<li>黑板上手写一个二分查找（注：写下了严书中的算法，技术员1指出了严书上二分查找的不足之处）</li>
<li>能不能耐住寂寞，面对50%的重复性劳动会怎样</li>
<li>英语问答环节</li>
<li>Self Introduction</li>
<li>Why don`t you go abroad</li>
<li>Short term and long term goals</li>
<li>Why do you choose automation as you major</li>
<li>Are you a popular person，how can you prove it</li>
<li>I think you are too confident , how do you think so</li>
<li>Who is always disappointed on you？<br>Hr：<br>一直在观察面试者，基本上没问问题<br>不足之处：STL底层，数据库查询语句。</li>
</ol>
<h3 id="4-酷我音乐"><a href="#4-酷我音乐" class="headerlink" title="4.酷我音乐"></a>4.酷我音乐</h3><p>公司：KUWO<br>转正：概率很高</p>
<p>2013.03.19</p>
<p>一面：</p>
<ol>
<li>多线程同步</li>
<li>快速排序时间复杂度，最好时间复杂度，以排序的数组，再进行快速排序，时间复杂度是多少</li>
<li>设计模式，写个单例模式，说说了解的设计模式</li>
<li>为什么控制跑来做软件开发</li>
</ol>
<p>二面：</p>
<ol>
<li>虚函数的作用，静态成员函数的作用</li>
<li>类对象的内存布局</li>
<li>在dll里面干掉一个线程会出现什么情况</li>
</ol>
<p>三面：</p>
<ol>
<li>如何快速从文件中读取数据，比如数据记录是姓名，年龄，性别，数据记录是顺序排列。查询的输入是第x条记录。（只回答对了建立文件映射，关键是不理解题目）</li>
<li>如何设计一个通用的单例模式</li>
<li>简历中为什么说善于发现bug，最近一次发现bug是什么时候，怎么解决的。有没有发现运行时期的bug</li>
</ol>
<p>四面：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;  *（&amp;a+<span class="number">1</span>）和*(&amp;a[<span class="number">0</span>] + <span class="number">1</span>)分别是多少</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line">&#125;</span><br><span class="line">Test test;</span><br><span class="line">&amp;test的值和 &amp;(test.m) 和 &amp;（test.a）的值的关系</span><br><span class="line">解释一下堆栈 和 堆的特点</span><br><span class="line">解释一下<span class="keyword">static_cast</span>和<span class="keyword">dynamic_cast</span>的区别</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a；如何获得a内部数组地址</span><br><span class="line">主线程等到子线程干完才能干事，主线程怎么知道子线程干完了？不能用内核同步方式。</span><br><span class="line">多维数组存储模型</span><br></pre></td></tr></table></figure>

<p>五面：<br>一个服务号码比如123456 对应的是下载音乐服务。有很多服务号码，分别对应不同的服务。这些号码不会超过13位。设计一个数据结构根据输入的码找到相应服务。<br>开始回答用map，查找的复杂度是O(nlogn）；<br>后来说如果输入的服务码多了会怎样，怎么容错？比如一个服务码是22221对应听故事服务，用户输入了222211111，如何任然定位到听故事服务。内存不限。<br>想到了基数排序，最后设计了一个算法，面试官说我设计的叫做字典树，我表示瞎猫碰死耗子</p>
<p>六面：<br>基本聊天，没问技术问题。</p>
<p>七面：<br>HR<br>不足之处：算法的分析，数据结构的了解。</p>
<h3 id="5-搜狗"><a href="#5-搜狗" class="headerlink" title="5.搜狗"></a>5.搜狗</h3><p>职位：Windows客户端浏览器开发</p>
<p>时间：2013.03.27</p>
<p>一面：</p>
<ol>
<li>虚析构函数的作用</li>
<li><code>void memcpy (void* dest, const void* src, size_t len)；</code>实现函数；有什么需要注意的？</li>
<li><code>list&lt;int&gt; iList；</code>删除所用等于某个特定值的元素</li>
<li>多进程通信用过哪些？</li>
<li>多线程同步方式？用过哪些？</li>
<li>WTL和COM的了解</li>
<li>是否用过模版？解释模版特化和偏特化</li>
<li>dll中new的对象在exe中删除是否合适？</li>
<li>exeA和exeB都载入dllC，问dllC是否在A和B中各有一份？</li>
<li>你是如何在不同工程中实现同种子功能的？</li>
<li>DC，客户区和非客户区，贴图图形闪烁的原因</li>
<li>1000万个人的身高，找出前20</li>
<li>txtA和txtB每行都是文本，求A和B内容相同的行 </li>
</ol>
<p><strong>不足之处：Win32中dll的了解。</strong></p>
<p>时间：2013.04.03</p>
<p>二面：</p>
<ol>
<li>如何获得当前exe运行的目录</li>
<li>vetor容器不停push_back导致容器的capacity增长，描述一下capacity增长的过程</li>
<li>双线程（一个读线程、一个写线程）同时对一块内存操作，比如int g_iNum;是否需要加锁？如果把整数换成list呢？</li>
<li>SendMessage 和 PostMessage的区别，如果窗口A和窗口B相互SendMessage会出现什么情况？</li>
<li>多线程同步,列举你用过的方式。Event 和 Mutex有什么区别？</li>
<li>自动重置的Event和获得Event后立即手动重置有什么区别？</li>
<li>dll载入后，怎么调用函数?</li>
<li>最近看了什么书？</li>
<li>为什么看了那么多书？不去实践一下？</li>
<li>如果老板交给你一个活，你怎么处理？</li>
<li>有没有女朋友？工作还是上学？如果她不能在北京找到工作怎么办？</li>
<li>找工作中是否户口很重要？如果一个国企有户口，和一个你喜欢干的工作没有户口，怎么选择？</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Hello World&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   A* p = <span class="literal">NULL</span>;</span><br><span class="line">   p-&gt;func();<span class="comment">//会出问题吗？</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;m_iTest&lt;&lt;<span class="built_in">endl</span>;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Hello World&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">     <span class="keyword">int</span>    m_iTest;</span><br><span class="line">&#125;;</span><br><span class="line">这样呢？调用p-&gt;func()会出问题吗？</span><br><span class="line"></span><br><span class="line">如果把 func函数设置为<span class="keyword">virtual</span>呢？ 问题出在哪一步？</span><br></pre></td></tr></table></figure>


<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A tmpA，tmpB；</span><br><span class="line">tmpA.func();</span><br><span class="line">tmpB.func();</span><br><span class="line">编译器怎知道是tmpA还是tmpB调用func呢？</span><br><span class="line"></span><br><span class="line">类的成员函数可以作为线程函数吗？</span><br><span class="line"></span><br><span class="line">为什么<span class="keyword">static</span>成员函数可以作为线程函数？</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>成员函数和普通的成员函数的区别在哪里？针对这个问题。。。</span><br></pre></td></tr></table></figure>

<p>不足之处：Win32中dll的了解。 </p>
<h3 id="6-豌豆荚"><a href="#6-豌豆荚" class="headerlink" title="6.豌豆荚"></a>6.豌豆荚</h3><p>一面：</p>
<p>实现大整数乘法</p>
<p>二面:</p>
<p>实现字符串匹配算法</p>
<h3 id="7-腾讯"><a href="#7-腾讯" class="headerlink" title="7.腾讯"></a>7.腾讯</h3><p>职位：Windows客户端浏览器开发</p>
<p>时间：2013.04.24</p>
<p>一面：</p>
<ol>
<li>MFC怎么实现消息映射</li>
<li>Windows程序的基本流程，创建的窗口怎么跟窗口过程绑定起来</li>
<li>C++看过什么书</li>
<li>说一下《Effective C++》中印象最深的一个条款</li>
<li>编译器为类默认实现的函数有哪些</li>
<li>C++怎么实现虚函数机制</li>
<li>A、B、C三个类，A是C的基类，同时C中包含有B的对象，A、B、C构造函数执行顺序</li>
<li>Vptr在哪里初始化的</li>
<li>Windows中多线程同步机制</li>
<li>Windows中有没有共享内存？ 文件映射的作用</li>
<li>用两个队列模拟一个堆栈</li>
<li>设计一个不能被继承的类</li>
<li>Heap和Stack的区别</li>
</ol>
<p>二面：</p>
<ol>
<li>C++看过什么书</li>
<li>Windows看过什么书</li>
<li>说一下Windows内存模型</li>
<li>Windows哪块比较熟悉？IO、内存管理、多线程？</li>
<li>怎么把单线程函数拆为多线程函数？比如用单线程对一张位图进行灰度化。怎么把这种单线程任务拆分为多线程</li>
<li>1G内存，两个exe。说一下内存占用情况</li>
</ol>
<p>三面：<br>HR </p>
<h3 id="8-阿里巴巴"><a href="#8-阿里巴巴" class="headerlink" title="8.阿里巴巴"></a>8.阿里巴巴</h3><p>时间：2013.05.21</p>
<p>一面：</p>
<ol>
<li>解释重载和多态</li>
<li>堆和栈的区别？应用场景分别是什么？</li>
<li>用过的类库？vector和list的区别。是否多线程安全的？</li>
<li>设计模式了解哪些？写一个单例模式</li>
<li>适配器模式是否了解？</li>
<li>是否做过多进程通讯？跨机器的进程通讯的方式有哪些？</li>
<li>说一下OSI七层模型</li>
<li>网络拥塞发生在哪一层？</li>
<li>tcp和udp区别</li>
<li>数据库了解多少？</li>
<li>有没有看过常用算法的工业级源码实现？如快速排序等</li>
<li>聊项目，做的东西</li>
<li>引申我做的项目，同一反射内存地址 怎么在多机器环境下保持读写不冲突？ </li>
</ol>
<p>二面：（后记）</p>
<ol>
<li>感觉写过最好的代码</li>
<li>一道算法题</li>
<li>聊了一下dota喜欢什么英雄</li>
</ol>
<p>三面：<br>HR</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="宿于松下"
      src="/assets/img/common/avatar.jpg">
  <p class="site-author-name" itemprop="name">宿于松下</p>
  <div class="site-description" itemprop="description">行有不得反求诸己</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/shunchengGit" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;shunchengGit" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:419187675@qq.com" title="E-Mail → mailto:419187675@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">宿于松下</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
